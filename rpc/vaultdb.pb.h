// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vaultdb.proto

#ifndef PROTOBUF_INCLUDED_vaultdb_2eproto
#define PROTOBUF_INCLUDED_vaultdb_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_vaultdb_2eproto 

namespace protobuf_vaultdb_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[41];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_vaultdb_2eproto
namespace vaultdb {
class CoaleseTablesRequest;
class CoaleseTablesRequestDefaultTypeInternal;
extern CoaleseTablesRequestDefaultTypeInternal _CoaleseTablesRequest_default_instance_;
class CoaleseTablesResponse;
class CoaleseTablesResponseDefaultTypeInternal;
extern CoaleseTablesResponseDefaultTypeInternal _CoaleseTablesResponse_default_instance_;
class ControlFlowColumn;
class ControlFlowColumnDefaultTypeInternal;
extern ControlFlowColumnDefaultTypeInternal _ControlFlowColumn_default_instance_;
class DBMSQueryRequest;
class DBMSQueryRequestDefaultTypeInternal;
extern DBMSQueryRequestDefaultTypeInternal _DBMSQueryRequest_default_instance_;
class DBMSQueryResponse;
class DBMSQueryResponseDefaultTypeInternal;
extern DBMSQueryResponseDefaultTypeInternal _DBMSQueryResponse_default_instance_;
class DBQueryRequest;
class DBQueryRequestDefaultTypeInternal;
extern DBQueryRequestDefaultTypeInternal _DBQueryRequest_default_instance_;
class DBQueryResponse;
class DBQueryResponseDefaultTypeInternal;
extern DBQueryResponseDefaultTypeInternal _DBQueryResponse_default_instance_;
class FieldDesc;
class FieldDescDefaultTypeInternal;
extern FieldDescDefaultTypeInternal _FieldDesc_default_instance_;
class GeneralizeRequest;
class GeneralizeRequestDefaultTypeInternal;
extern GeneralizeRequestDefaultTypeInternal _GeneralizeRequest_default_instance_;
class GeneralizeResponse;
class GeneralizeResponseDefaultTypeInternal;
extern GeneralizeResponseDefaultTypeInternal _GeneralizeResponse_default_instance_;
class GetControlFlowColumnRequest;
class GetControlFlowColumnRequestDefaultTypeInternal;
extern GetControlFlowColumnRequestDefaultTypeInternal _GetControlFlowColumnRequest_default_instance_;
class GetControlFlowColumnResponse;
class GetControlFlowColumnResponseDefaultTypeInternal;
extern GetControlFlowColumnResponseDefaultTypeInternal _GetControlFlowColumnResponse_default_instance_;
class GetPeerHostsRequest;
class GetPeerHostsRequestDefaultTypeInternal;
extern GetPeerHostsRequestDefaultTypeInternal _GetPeerHostsRequest_default_instance_;
class GetPeerHostsResponse;
class GetPeerHostsResponseDefaultTypeInternal;
extern GetPeerHostsResponseDefaultTypeInternal _GetPeerHostsResponse_default_instance_;
class KFilterRequest;
class KFilterRequestDefaultTypeInternal;
extern KFilterRequestDefaultTypeInternal _KFilterRequest_default_instance_;
class KFilterResponse;
class KFilterResponseDefaultTypeInternal;
extern KFilterResponseDefaultTypeInternal _KFilterResponse_default_instance_;
class KJoinRequest;
class KJoinRequestDefaultTypeInternal;
extern KJoinRequestDefaultTypeInternal _KJoinRequest_default_instance_;
class KJoinResponse;
class KJoinResponseDefaultTypeInternal;
extern KJoinResponseDefaultTypeInternal _KJoinResponse_default_instance_;
class KSortRequest;
class KSortRequestDefaultTypeInternal;
extern KSortRequestDefaultTypeInternal _KSortRequest_default_instance_;
class KSortResponse;
class KSortResponseDefaultTypeInternal;
extern KSortResponseDefaultTypeInternal _KSortResponse_default_instance_;
class NumHostResp;
class NumHostRespDefaultTypeInternal;
extern NumHostRespDefaultTypeInternal _NumHostResp_default_instance_;
class NumHostsRequest;
class NumHostsRequestDefaultTypeInternal;
extern NumHostsRequestDefaultTypeInternal _NumHostsRequest_default_instance_;
class PeerHostInfo;
class PeerHostInfoDefaultTypeInternal;
extern PeerHostInfoDefaultTypeInternal _PeerHostInfo_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class RepartitionStepOneRequest;
class RepartitionStepOneRequestDefaultTypeInternal;
extern RepartitionStepOneRequestDefaultTypeInternal _RepartitionStepOneRequest_default_instance_;
class RepartitionStepOneResponse;
class RepartitionStepOneResponseDefaultTypeInternal;
extern RepartitionStepOneResponseDefaultTypeInternal _RepartitionStepOneResponse_default_instance_;
class RepartitionStepTwoRequest;
class RepartitionStepTwoRequestDefaultTypeInternal;
extern RepartitionStepTwoRequestDefaultTypeInternal _RepartitionStepTwoRequest_default_instance_;
class RepartitionStepTwoResponse;
class RepartitionStepTwoResponseDefaultTypeInternal;
extern RepartitionStepTwoResponseDefaultTypeInternal _RepartitionStepTwoResponse_default_instance_;
class Schema;
class SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SendTableRequest;
class SendTableRequestDefaultTypeInternal;
extern SendTableRequestDefaultTypeInternal _SendTableRequest_default_instance_;
class SendTableResponse;
class SendTableResponseDefaultTypeInternal;
extern SendTableResponseDefaultTypeInternal _SendTableResponse_default_instance_;
class Table;
class TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class TableID;
class TableIDDefaultTypeInternal;
extern TableIDDefaultTypeInternal _TableID_default_instance_;
class TableQueryRequest;
class TableQueryRequestDefaultTypeInternal;
extern TableQueryRequestDefaultTypeInternal _TableQueryRequest_default_instance_;
class TableQueryResponse;
class TableQueryResponseDefaultTypeInternal;
extern TableQueryResponseDefaultTypeInternal _TableQueryResponse_default_instance_;
class TableRequest;
class TableRequestDefaultTypeInternal;
extern TableRequestDefaultTypeInternal _TableRequest_default_instance_;
class TableResponse;
class TableResponseDefaultTypeInternal;
extern TableResponseDefaultTypeInternal _TableResponse_default_instance_;
class TableStream;
class TableStreamDefaultTypeInternal;
extern TableStreamDefaultTypeInternal _TableStream_default_instance_;
class TuplePage;
class TuplePageDefaultTypeInternal;
extern TuplePageDefaultTypeInternal _TuplePage_default_instance_;
class schema;
class schemaDefaultTypeInternal;
extern schemaDefaultTypeInternal _schema_default_instance_;
}  // namespace vaultdb
namespace google {
namespace protobuf {
template<> ::vaultdb::CoaleseTablesRequest* Arena::CreateMaybeMessage<::vaultdb::CoaleseTablesRequest>(Arena*);
template<> ::vaultdb::CoaleseTablesResponse* Arena::CreateMaybeMessage<::vaultdb::CoaleseTablesResponse>(Arena*);
template<> ::vaultdb::ControlFlowColumn* Arena::CreateMaybeMessage<::vaultdb::ControlFlowColumn>(Arena*);
template<> ::vaultdb::DBMSQueryRequest* Arena::CreateMaybeMessage<::vaultdb::DBMSQueryRequest>(Arena*);
template<> ::vaultdb::DBMSQueryResponse* Arena::CreateMaybeMessage<::vaultdb::DBMSQueryResponse>(Arena*);
template<> ::vaultdb::DBQueryRequest* Arena::CreateMaybeMessage<::vaultdb::DBQueryRequest>(Arena*);
template<> ::vaultdb::DBQueryResponse* Arena::CreateMaybeMessage<::vaultdb::DBQueryResponse>(Arena*);
template<> ::vaultdb::FieldDesc* Arena::CreateMaybeMessage<::vaultdb::FieldDesc>(Arena*);
template<> ::vaultdb::GeneralizeRequest* Arena::CreateMaybeMessage<::vaultdb::GeneralizeRequest>(Arena*);
template<> ::vaultdb::GeneralizeResponse* Arena::CreateMaybeMessage<::vaultdb::GeneralizeResponse>(Arena*);
template<> ::vaultdb::GetControlFlowColumnRequest* Arena::CreateMaybeMessage<::vaultdb::GetControlFlowColumnRequest>(Arena*);
template<> ::vaultdb::GetControlFlowColumnResponse* Arena::CreateMaybeMessage<::vaultdb::GetControlFlowColumnResponse>(Arena*);
template<> ::vaultdb::GetPeerHostsRequest* Arena::CreateMaybeMessage<::vaultdb::GetPeerHostsRequest>(Arena*);
template<> ::vaultdb::GetPeerHostsResponse* Arena::CreateMaybeMessage<::vaultdb::GetPeerHostsResponse>(Arena*);
template<> ::vaultdb::KFilterRequest* Arena::CreateMaybeMessage<::vaultdb::KFilterRequest>(Arena*);
template<> ::vaultdb::KFilterResponse* Arena::CreateMaybeMessage<::vaultdb::KFilterResponse>(Arena*);
template<> ::vaultdb::KJoinRequest* Arena::CreateMaybeMessage<::vaultdb::KJoinRequest>(Arena*);
template<> ::vaultdb::KJoinResponse* Arena::CreateMaybeMessage<::vaultdb::KJoinResponse>(Arena*);
template<> ::vaultdb::KSortRequest* Arena::CreateMaybeMessage<::vaultdb::KSortRequest>(Arena*);
template<> ::vaultdb::KSortResponse* Arena::CreateMaybeMessage<::vaultdb::KSortResponse>(Arena*);
template<> ::vaultdb::NumHostResp* Arena::CreateMaybeMessage<::vaultdb::NumHostResp>(Arena*);
template<> ::vaultdb::NumHostsRequest* Arena::CreateMaybeMessage<::vaultdb::NumHostsRequest>(Arena*);
template<> ::vaultdb::PeerHostInfo* Arena::CreateMaybeMessage<::vaultdb::PeerHostInfo>(Arena*);
template<> ::vaultdb::RegisterRequest* Arena::CreateMaybeMessage<::vaultdb::RegisterRequest>(Arena*);
template<> ::vaultdb::RegisterResponse* Arena::CreateMaybeMessage<::vaultdb::RegisterResponse>(Arena*);
template<> ::vaultdb::RepartitionStepOneRequest* Arena::CreateMaybeMessage<::vaultdb::RepartitionStepOneRequest>(Arena*);
template<> ::vaultdb::RepartitionStepOneResponse* Arena::CreateMaybeMessage<::vaultdb::RepartitionStepOneResponse>(Arena*);
template<> ::vaultdb::RepartitionStepTwoRequest* Arena::CreateMaybeMessage<::vaultdb::RepartitionStepTwoRequest>(Arena*);
template<> ::vaultdb::RepartitionStepTwoResponse* Arena::CreateMaybeMessage<::vaultdb::RepartitionStepTwoResponse>(Arena*);
template<> ::vaultdb::Schema* Arena::CreateMaybeMessage<::vaultdb::Schema>(Arena*);
template<> ::vaultdb::SendTableRequest* Arena::CreateMaybeMessage<::vaultdb::SendTableRequest>(Arena*);
template<> ::vaultdb::SendTableResponse* Arena::CreateMaybeMessage<::vaultdb::SendTableResponse>(Arena*);
template<> ::vaultdb::Table* Arena::CreateMaybeMessage<::vaultdb::Table>(Arena*);
template<> ::vaultdb::TableID* Arena::CreateMaybeMessage<::vaultdb::TableID>(Arena*);
template<> ::vaultdb::TableQueryRequest* Arena::CreateMaybeMessage<::vaultdb::TableQueryRequest>(Arena*);
template<> ::vaultdb::TableQueryResponse* Arena::CreateMaybeMessage<::vaultdb::TableQueryResponse>(Arena*);
template<> ::vaultdb::TableRequest* Arena::CreateMaybeMessage<::vaultdb::TableRequest>(Arena*);
template<> ::vaultdb::TableResponse* Arena::CreateMaybeMessage<::vaultdb::TableResponse>(Arena*);
template<> ::vaultdb::TableStream* Arena::CreateMaybeMessage<::vaultdb::TableStream>(Arena*);
template<> ::vaultdb::TuplePage* Arena::CreateMaybeMessage<::vaultdb::TuplePage>(Arena*);
template<> ::vaultdb::schema* Arena::CreateMaybeMessage<::vaultdb::schema>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vaultdb {

enum FieldDesc_FieldType {
  FieldDesc_FieldType_UNSUPPORTED = 0,
  FieldDesc_FieldType_FIXEDCHAR = 1,
  FieldDesc_FieldType_INT = 2,
  FieldDesc_FieldType_FieldDesc_FieldType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FieldDesc_FieldType_FieldDesc_FieldType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FieldDesc_FieldType_IsValid(int value);
const FieldDesc_FieldType FieldDesc_FieldType_FieldType_MIN = FieldDesc_FieldType_UNSUPPORTED;
const FieldDesc_FieldType FieldDesc_FieldType_FieldType_MAX = FieldDesc_FieldType_INT;
const int FieldDesc_FieldType_FieldType_ARRAYSIZE = FieldDesc_FieldType_FieldType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FieldDesc_FieldType_descriptor();
inline const ::std::string& FieldDesc_FieldType_Name(FieldDesc_FieldType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FieldDesc_FieldType_descriptor(), value);
}
inline bool FieldDesc_FieldType_Parse(
    const ::std::string& name, FieldDesc_FieldType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FieldDesc_FieldType>(
    FieldDesc_FieldType_descriptor(), name, value);
}
// ===================================================================

class CoaleseTablesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.CoaleseTablesRequest) */ {
 public:
  CoaleseTablesRequest();
  virtual ~CoaleseTablesRequest();

  CoaleseTablesRequest(const CoaleseTablesRequest& from);

  inline CoaleseTablesRequest& operator=(const CoaleseTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoaleseTablesRequest(CoaleseTablesRequest&& from) noexcept
    : CoaleseTablesRequest() {
    *this = ::std::move(from);
  }

  inline CoaleseTablesRequest& operator=(CoaleseTablesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CoaleseTablesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoaleseTablesRequest* internal_default_instance() {
    return reinterpret_cast<const CoaleseTablesRequest*>(
               &_CoaleseTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CoaleseTablesRequest* other);
  friend void swap(CoaleseTablesRequest& a, CoaleseTablesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoaleseTablesRequest* New() const final {
    return CreateMaybeMessage<CoaleseTablesRequest>(NULL);
  }

  CoaleseTablesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CoaleseTablesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CoaleseTablesRequest& from);
  void MergeFrom(const CoaleseTablesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoaleseTablesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vaultdb.TableID tablefragments = 1;
  int tablefragments_size() const;
  void clear_tablefragments();
  static const int kTablefragmentsFieldNumber = 1;
  ::vaultdb::TableID* mutable_tablefragments(int index);
  ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >*
      mutable_tablefragments();
  const ::vaultdb::TableID& tablefragments(int index) const;
  ::vaultdb::TableID* add_tablefragments();
  const ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >&
      tablefragments() const;

  // @@protoc_insertion_point(class_scope:vaultdb.CoaleseTablesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID > tablefragments_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CoaleseTablesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.CoaleseTablesResponse) */ {
 public:
  CoaleseTablesResponse();
  virtual ~CoaleseTablesResponse();

  CoaleseTablesResponse(const CoaleseTablesResponse& from);

  inline CoaleseTablesResponse& operator=(const CoaleseTablesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoaleseTablesResponse(CoaleseTablesResponse&& from) noexcept
    : CoaleseTablesResponse() {
    *this = ::std::move(from);
  }

  inline CoaleseTablesResponse& operator=(CoaleseTablesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CoaleseTablesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoaleseTablesResponse* internal_default_instance() {
    return reinterpret_cast<const CoaleseTablesResponse*>(
               &_CoaleseTablesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CoaleseTablesResponse* other);
  friend void swap(CoaleseTablesResponse& a, CoaleseTablesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoaleseTablesResponse* New() const final {
    return CreateMaybeMessage<CoaleseTablesResponse>(NULL);
  }

  CoaleseTablesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CoaleseTablesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CoaleseTablesResponse& from);
  void MergeFrom(const CoaleseTablesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoaleseTablesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vaultdb.TableID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::vaultdb::TableID& _internal_id() const;
  public:
  const ::vaultdb::TableID& id() const;
  ::vaultdb::TableID* release_id();
  ::vaultdb::TableID* mutable_id();
  void set_allocated_id(::vaultdb::TableID* id);

  // @@protoc_insertion_point(class_scope:vaultdb.CoaleseTablesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vaultdb::TableID* id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetControlFlowColumnRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.GetControlFlowColumnRequest) */ {
 public:
  GetControlFlowColumnRequest();
  virtual ~GetControlFlowColumnRequest();

  GetControlFlowColumnRequest(const GetControlFlowColumnRequest& from);

  inline GetControlFlowColumnRequest& operator=(const GetControlFlowColumnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetControlFlowColumnRequest(GetControlFlowColumnRequest&& from) noexcept
    : GetControlFlowColumnRequest() {
    *this = ::std::move(from);
  }

  inline GetControlFlowColumnRequest& operator=(GetControlFlowColumnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetControlFlowColumnRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetControlFlowColumnRequest* internal_default_instance() {
    return reinterpret_cast<const GetControlFlowColumnRequest*>(
               &_GetControlFlowColumnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetControlFlowColumnRequest* other);
  friend void swap(GetControlFlowColumnRequest& a, GetControlFlowColumnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetControlFlowColumnRequest* New() const final {
    return CreateMaybeMessage<GetControlFlowColumnRequest>(NULL);
  }

  GetControlFlowColumnRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetControlFlowColumnRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetControlFlowColumnRequest& from);
  void MergeFrom(const GetControlFlowColumnRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetControlFlowColumnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.GetControlFlowColumnRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetControlFlowColumnResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.GetControlFlowColumnResponse) */ {
 public:
  GetControlFlowColumnResponse();
  virtual ~GetControlFlowColumnResponse();

  GetControlFlowColumnResponse(const GetControlFlowColumnResponse& from);

  inline GetControlFlowColumnResponse& operator=(const GetControlFlowColumnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetControlFlowColumnResponse(GetControlFlowColumnResponse&& from) noexcept
    : GetControlFlowColumnResponse() {
    *this = ::std::move(from);
  }

  inline GetControlFlowColumnResponse& operator=(GetControlFlowColumnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetControlFlowColumnResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetControlFlowColumnResponse* internal_default_instance() {
    return reinterpret_cast<const GetControlFlowColumnResponse*>(
               &_GetControlFlowColumnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetControlFlowColumnResponse* other);
  friend void swap(GetControlFlowColumnResponse& a, GetControlFlowColumnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetControlFlowColumnResponse* New() const final {
    return CreateMaybeMessage<GetControlFlowColumnResponse>(NULL);
  }

  GetControlFlowColumnResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetControlFlowColumnResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetControlFlowColumnResponse& from);
  void MergeFrom(const GetControlFlowColumnResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetControlFlowColumnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vaultdb.ControlFlowColumn cf = 1;
  bool has_cf() const;
  void clear_cf();
  static const int kCfFieldNumber = 1;
  private:
  const ::vaultdb::ControlFlowColumn& _internal_cf() const;
  public:
  const ::vaultdb::ControlFlowColumn& cf() const;
  ::vaultdb::ControlFlowColumn* release_cf();
  ::vaultdb::ControlFlowColumn* mutable_cf();
  void set_allocated_cf(::vaultdb::ControlFlowColumn* cf);

  // @@protoc_insertion_point(class_scope:vaultdb.GetControlFlowColumnResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vaultdb::ControlFlowColumn* cf_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControlFlowColumn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.ControlFlowColumn) */ {
 public:
  ControlFlowColumn();
  virtual ~ControlFlowColumn();

  ControlFlowColumn(const ControlFlowColumn& from);

  inline ControlFlowColumn& operator=(const ControlFlowColumn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlFlowColumn(ControlFlowColumn&& from) noexcept
    : ControlFlowColumn() {
    *this = ::std::move(from);
  }

  inline ControlFlowColumn& operator=(ControlFlowColumn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlFlowColumn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlFlowColumn* internal_default_instance() {
    return reinterpret_cast<const ControlFlowColumn*>(
               &_ControlFlowColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ControlFlowColumn* other);
  friend void swap(ControlFlowColumn& a, ControlFlowColumn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlFlowColumn* New() const final {
    return CreateMaybeMessage<ControlFlowColumn>(NULL);
  }

  ControlFlowColumn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlFlowColumn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlFlowColumn& from);
  void MergeFrom(const ControlFlowColumn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlFlowColumn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 cfid = 1;
  void clear_cfid();
  static const int kCfidFieldNumber = 1;
  ::google::protobuf::int32 cfid() const;
  void set_cfid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.ControlFlowColumn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 cfid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RepartitionStepTwoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.RepartitionStepTwoRequest) */ {
 public:
  RepartitionStepTwoRequest();
  virtual ~RepartitionStepTwoRequest();

  RepartitionStepTwoRequest(const RepartitionStepTwoRequest& from);

  inline RepartitionStepTwoRequest& operator=(const RepartitionStepTwoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepartitionStepTwoRequest(RepartitionStepTwoRequest&& from) noexcept
    : RepartitionStepTwoRequest() {
    *this = ::std::move(from);
  }

  inline RepartitionStepTwoRequest& operator=(RepartitionStepTwoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RepartitionStepTwoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepartitionStepTwoRequest* internal_default_instance() {
    return reinterpret_cast<const RepartitionStepTwoRequest*>(
               &_RepartitionStepTwoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RepartitionStepTwoRequest* other);
  friend void swap(RepartitionStepTwoRequest& a, RepartitionStepTwoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepartitionStepTwoRequest* New() const final {
    return CreateMaybeMessage<RepartitionStepTwoRequest>(NULL);
  }

  RepartitionStepTwoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepartitionStepTwoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepartitionStepTwoRequest& from);
  void MergeFrom(const RepartitionStepTwoRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepartitionStepTwoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vaultdb.TableID tablefragments = 1;
  int tablefragments_size() const;
  void clear_tablefragments();
  static const int kTablefragmentsFieldNumber = 1;
  ::vaultdb::TableID* mutable_tablefragments(int index);
  ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >*
      mutable_tablefragments();
  const ::vaultdb::TableID& tablefragments(int index) const;
  ::vaultdb::TableID* add_tablefragments();
  const ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >&
      tablefragments() const;

  // @@protoc_insertion_point(class_scope:vaultdb.RepartitionStepTwoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID > tablefragments_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RepartitionStepTwoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.RepartitionStepTwoResponse) */ {
 public:
  RepartitionStepTwoResponse();
  virtual ~RepartitionStepTwoResponse();

  RepartitionStepTwoResponse(const RepartitionStepTwoResponse& from);

  inline RepartitionStepTwoResponse& operator=(const RepartitionStepTwoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepartitionStepTwoResponse(RepartitionStepTwoResponse&& from) noexcept
    : RepartitionStepTwoResponse() {
    *this = ::std::move(from);
  }

  inline RepartitionStepTwoResponse& operator=(RepartitionStepTwoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RepartitionStepTwoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepartitionStepTwoResponse* internal_default_instance() {
    return reinterpret_cast<const RepartitionStepTwoResponse*>(
               &_RepartitionStepTwoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RepartitionStepTwoResponse* other);
  friend void swap(RepartitionStepTwoResponse& a, RepartitionStepTwoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepartitionStepTwoResponse* New() const final {
    return CreateMaybeMessage<RepartitionStepTwoResponse>(NULL);
  }

  RepartitionStepTwoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepartitionStepTwoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepartitionStepTwoResponse& from);
  void MergeFrom(const RepartitionStepTwoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepartitionStepTwoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vaultdb.TableID remoteRepartitionIDs = 1;
  int remoterepartitionids_size() const;
  void clear_remoterepartitionids();
  static const int kRemoteRepartitionIDsFieldNumber = 1;
  ::vaultdb::TableID* mutable_remoterepartitionids(int index);
  ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >*
      mutable_remoterepartitionids();
  const ::vaultdb::TableID& remoterepartitionids(int index) const;
  ::vaultdb::TableID* add_remoterepartitionids();
  const ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >&
      remoterepartitionids() const;

  // @@protoc_insertion_point(class_scope:vaultdb.RepartitionStepTwoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID > remoterepartitionids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RepartitionStepOneRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.RepartitionStepOneRequest) */ {
 public:
  RepartitionStepOneRequest();
  virtual ~RepartitionStepOneRequest();

  RepartitionStepOneRequest(const RepartitionStepOneRequest& from);

  inline RepartitionStepOneRequest& operator=(const RepartitionStepOneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepartitionStepOneRequest(RepartitionStepOneRequest&& from) noexcept
    : RepartitionStepOneRequest() {
    *this = ::std::move(from);
  }

  inline RepartitionStepOneRequest& operator=(RepartitionStepOneRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RepartitionStepOneRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepartitionStepOneRequest* internal_default_instance() {
    return reinterpret_cast<const RepartitionStepOneRequest*>(
               &_RepartitionStepOneRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RepartitionStepOneRequest* other);
  friend void swap(RepartitionStepOneRequest& a, RepartitionStepOneRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepartitionStepOneRequest* New() const final {
    return CreateMaybeMessage<RepartitionStepOneRequest>(NULL);
  }

  RepartitionStepOneRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepartitionStepOneRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepartitionStepOneRequest& from);
  void MergeFrom(const RepartitionStepOneRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepartitionStepOneRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vaultdb.TableID tableid = 1;
  bool has_tableid() const;
  void clear_tableid();
  static const int kTableidFieldNumber = 1;
  private:
  const ::vaultdb::TableID& _internal_tableid() const;
  public:
  const ::vaultdb::TableID& tableid() const;
  ::vaultdb::TableID* release_tableid();
  ::vaultdb::TableID* mutable_tableid();
  void set_allocated_tableid(::vaultdb::TableID* tableid);

  // @@protoc_insertion_point(class_scope:vaultdb.RepartitionStepOneRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vaultdb::TableID* tableid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.TableID) */ {
 public:
  TableID();
  virtual ~TableID();

  TableID(const TableID& from);

  inline TableID& operator=(const TableID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableID(TableID&& from) noexcept
    : TableID() {
    *this = ::std::move(from);
  }

  inline TableID& operator=(TableID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableID* internal_default_instance() {
    return reinterpret_cast<const TableID*>(
               &_TableID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TableID* other);
  friend void swap(TableID& a, TableID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableID* New() const final {
    return CreateMaybeMessage<TableID>(NULL);
  }

  TableID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableID& from);
  void MergeFrom(const TableID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string dbname = 1;
  void clear_dbname();
  static const int kDbnameFieldNumber = 1;
  const ::std::string& dbname() const;
  void set_dbname(const ::std::string& value);
  #if LANG_CXX11
  void set_dbname(::std::string&& value);
  #endif
  void set_dbname(const char* value);
  void set_dbname(const char* value, size_t size);
  ::std::string* mutable_dbname();
  ::std::string* release_dbname();
  void set_allocated_dbname(::std::string* dbname);

  // string query = 2;
  void clear_query();
  static const int kQueryFieldNumber = 2;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // int32 hostnum = 3;
  void clear_hostnum();
  static const int kHostnumFieldNumber = 3;
  ::google::protobuf::int32 hostnum() const;
  void set_hostnum(::google::protobuf::int32 value);

  // int32 tableid = 4;
  void clear_tableid();
  static const int kTableidFieldNumber = 4;
  ::google::protobuf::int32 tableid() const;
  void set_tableid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.TableID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dbname_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  ::google::protobuf::int32 hostnum_;
  ::google::protobuf::int32 tableid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RepartitionStepOneResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.RepartitionStepOneResponse) */ {
 public:
  RepartitionStepOneResponse();
  virtual ~RepartitionStepOneResponse();

  RepartitionStepOneResponse(const RepartitionStepOneResponse& from);

  inline RepartitionStepOneResponse& operator=(const RepartitionStepOneResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepartitionStepOneResponse(RepartitionStepOneResponse&& from) noexcept
    : RepartitionStepOneResponse() {
    *this = ::std::move(from);
  }

  inline RepartitionStepOneResponse& operator=(RepartitionStepOneResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RepartitionStepOneResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepartitionStepOneResponse* internal_default_instance() {
    return reinterpret_cast<const RepartitionStepOneResponse*>(
               &_RepartitionStepOneResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(RepartitionStepOneResponse* other);
  friend void swap(RepartitionStepOneResponse& a, RepartitionStepOneResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepartitionStepOneResponse* New() const final {
    return CreateMaybeMessage<RepartitionStepOneResponse>(NULL);
  }

  RepartitionStepOneResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepartitionStepOneResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepartitionStepOneResponse& from);
  void MergeFrom(const RepartitionStepOneResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepartitionStepOneResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vaultdb.TableID remoteRepartitionIDs = 1;
  int remoterepartitionids_size() const;
  void clear_remoterepartitionids();
  static const int kRemoteRepartitionIDsFieldNumber = 1;
  ::vaultdb::TableID* mutable_remoterepartitionids(int index);
  ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >*
      mutable_remoterepartitionids();
  const ::vaultdb::TableID& remoterepartitionids(int index) const;
  ::vaultdb::TableID* add_remoterepartitionids();
  const ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >&
      remoterepartitionids() const;

  // @@protoc_insertion_point(class_scope:vaultdb.RepartitionStepOneResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID > remoterepartitionids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendTableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.SendTableRequest) */ {
 public:
  SendTableRequest();
  virtual ~SendTableRequest();

  SendTableRequest(const SendTableRequest& from);

  inline SendTableRequest& operator=(const SendTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendTableRequest(SendTableRequest&& from) noexcept
    : SendTableRequest() {
    *this = ::std::move(from);
  }

  inline SendTableRequest& operator=(SendTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendTableRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendTableRequest* internal_default_instance() {
    return reinterpret_cast<const SendTableRequest*>(
               &_SendTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SendTableRequest* other);
  friend void swap(SendTableRequest& a, SendTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendTableRequest* New() const final {
    return CreateMaybeMessage<SendTableRequest>(NULL);
  }

  SendTableRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendTableRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SendTableRequest& from);
  void MergeFrom(const SendTableRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes page = 8;
  void clear_page();
  static const int kPageFieldNumber = 8;
  const ::std::string& page() const;
  void set_page(const ::std::string& value);
  #if LANG_CXX11
  void set_page(::std::string&& value);
  #endif
  void set_page(const char* value);
  void set_page(const void* value, size_t size);
  ::std::string* mutable_page();
  ::std::string* release_page();
  void set_allocated_page(::std::string* page);

  // .vaultdb.Schema schema = 3;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 3;
  private:
  const ::vaultdb::Schema& _internal_schema() const;
  public:
  const ::vaultdb::Schema& schema() const;
  ::vaultdb::Schema* release_schema();
  ::vaultdb::Schema* mutable_schema();
  void set_allocated_schema(::vaultdb::Schema* schema);

  // bool is_header = 2;
  void clear_is_header();
  static const int kIsHeaderFieldNumber = 2;
  bool is_header() const;
  void set_is_header(bool value);

  // int32 num_tuples = 4;
  void clear_num_tuples();
  static const int kNumTuplesFieldNumber = 4;
  ::google::protobuf::int32 num_tuples() const;
  void set_num_tuples(::google::protobuf::int32 value);

  // int32 size_of_tuple = 5;
  void clear_size_of_tuple();
  static const int kSizeOfTupleFieldNumber = 5;
  ::google::protobuf::int32 size_of_tuple() const;
  void set_size_of_tuple(::google::protobuf::int32 value);

  // int32 num_tuple_pages = 6;
  void clear_num_tuple_pages();
  static const int kNumTuplePagesFieldNumber = 6;
  ::google::protobuf::int32 num_tuple_pages() const;
  void set_num_tuple_pages(::google::protobuf::int32 value);

  // int32 page_no = 7;
  void clear_page_no();
  static const int kPageNoFieldNumber = 7;
  ::google::protobuf::int32 page_no() const;
  void set_page_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.SendTableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr page_;
  ::vaultdb::Schema* schema_;
  bool is_header_;
  ::google::protobuf::int32 num_tuples_;
  ::google::protobuf::int32 size_of_tuple_;
  ::google::protobuf::int32 num_tuple_pages_;
  ::google::protobuf::int32 page_no_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendTableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.SendTableResponse) */ {
 public:
  SendTableResponse();
  virtual ~SendTableResponse();

  SendTableResponse(const SendTableResponse& from);

  inline SendTableResponse& operator=(const SendTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendTableResponse(SendTableResponse&& from) noexcept
    : SendTableResponse() {
    *this = ::std::move(from);
  }

  inline SendTableResponse& operator=(SendTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendTableResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendTableResponse* internal_default_instance() {
    return reinterpret_cast<const SendTableResponse*>(
               &_SendTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SendTableResponse* other);
  friend void swap(SendTableResponse& a, SendTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendTableResponse* New() const final {
    return CreateMaybeMessage<SendTableResponse>(NULL);
  }

  SendTableResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendTableResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SendTableResponse& from);
  void MergeFrom(const SendTableResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 tableID = 1;
  void clear_tableid();
  static const int kTableIDFieldNumber = 1;
  ::google::protobuf::int32 tableid() const;
  void set_tableid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.SendTableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 tableid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KFilterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.KFilterRequest) */ {
 public:
  KFilterRequest();
  virtual ~KFilterRequest();

  KFilterRequest(const KFilterRequest& from);

  inline KFilterRequest& operator=(const KFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KFilterRequest(KFilterRequest&& from) noexcept
    : KFilterRequest() {
    *this = ::std::move(from);
  }

  inline KFilterRequest& operator=(KFilterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KFilterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KFilterRequest* internal_default_instance() {
    return reinterpret_cast<const KFilterRequest*>(
               &_KFilterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(KFilterRequest* other);
  friend void swap(KFilterRequest& a, KFilterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KFilterRequest* New() const final {
    return CreateMaybeMessage<KFilterRequest>(NULL);
  }

  KFilterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KFilterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KFilterRequest& from);
  void MergeFrom(const KFilterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KFilterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 tableID = 1;
  void clear_tableid();
  static const int kTableIDFieldNumber = 1;
  ::google::protobuf::int32 tableid() const;
  void set_tableid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.KFilterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 tableid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KFilterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.KFilterResponse) */ {
 public:
  KFilterResponse();
  virtual ~KFilterResponse();

  KFilterResponse(const KFilterResponse& from);

  inline KFilterResponse& operator=(const KFilterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KFilterResponse(KFilterResponse&& from) noexcept
    : KFilterResponse() {
    *this = ::std::move(from);
  }

  inline KFilterResponse& operator=(KFilterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KFilterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KFilterResponse* internal_default_instance() {
    return reinterpret_cast<const KFilterResponse*>(
               &_KFilterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(KFilterResponse* other);
  friend void swap(KFilterResponse& a, KFilterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KFilterResponse* New() const final {
    return CreateMaybeMessage<KFilterResponse>(NULL);
  }

  KFilterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KFilterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KFilterResponse& from);
  void MergeFrom(const KFilterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KFilterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.KFilterResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KJoinRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.KJoinRequest) */ {
 public:
  KJoinRequest();
  virtual ~KJoinRequest();

  KJoinRequest(const KJoinRequest& from);

  inline KJoinRequest& operator=(const KJoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KJoinRequest(KJoinRequest&& from) noexcept
    : KJoinRequest() {
    *this = ::std::move(from);
  }

  inline KJoinRequest& operator=(KJoinRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KJoinRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KJoinRequest* internal_default_instance() {
    return reinterpret_cast<const KJoinRequest*>(
               &_KJoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(KJoinRequest* other);
  friend void swap(KJoinRequest& a, KJoinRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KJoinRequest* New() const final {
    return CreateMaybeMessage<KJoinRequest>(NULL);
  }

  KJoinRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KJoinRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KJoinRequest& from);
  void MergeFrom(const KJoinRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KJoinRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.KJoinRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KJoinResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.KJoinResponse) */ {
 public:
  KJoinResponse();
  virtual ~KJoinResponse();

  KJoinResponse(const KJoinResponse& from);

  inline KJoinResponse& operator=(const KJoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KJoinResponse(KJoinResponse&& from) noexcept
    : KJoinResponse() {
    *this = ::std::move(from);
  }

  inline KJoinResponse& operator=(KJoinResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KJoinResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KJoinResponse* internal_default_instance() {
    return reinterpret_cast<const KJoinResponse*>(
               &_KJoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(KJoinResponse* other);
  friend void swap(KJoinResponse& a, KJoinResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KJoinResponse* New() const final {
    return CreateMaybeMessage<KJoinResponse>(NULL);
  }

  KJoinResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KJoinResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KJoinResponse& from);
  void MergeFrom(const KJoinResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KJoinResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.KJoinResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KSortRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.KSortRequest) */ {
 public:
  KSortRequest();
  virtual ~KSortRequest();

  KSortRequest(const KSortRequest& from);

  inline KSortRequest& operator=(const KSortRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KSortRequest(KSortRequest&& from) noexcept
    : KSortRequest() {
    *this = ::std::move(from);
  }

  inline KSortRequest& operator=(KSortRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KSortRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KSortRequest* internal_default_instance() {
    return reinterpret_cast<const KSortRequest*>(
               &_KSortRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(KSortRequest* other);
  friend void swap(KSortRequest& a, KSortRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KSortRequest* New() const final {
    return CreateMaybeMessage<KSortRequest>(NULL);
  }

  KSortRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KSortRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KSortRequest& from);
  void MergeFrom(const KSortRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KSortRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.KSortRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KSortResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.KSortResponse) */ {
 public:
  KSortResponse();
  virtual ~KSortResponse();

  KSortResponse(const KSortResponse& from);

  inline KSortResponse& operator=(const KSortResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KSortResponse(KSortResponse&& from) noexcept
    : KSortResponse() {
    *this = ::std::move(from);
  }

  inline KSortResponse& operator=(KSortResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KSortResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KSortResponse* internal_default_instance() {
    return reinterpret_cast<const KSortResponse*>(
               &_KSortResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(KSortResponse* other);
  friend void swap(KSortResponse& a, KSortResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KSortResponse* New() const final {
    return CreateMaybeMessage<KSortResponse>(NULL);
  }

  KSortResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KSortResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KSortResponse& from);
  void MergeFrom(const KSortResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KSortResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.KSortResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GeneralizeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.GeneralizeRequest) */ {
 public:
  GeneralizeRequest();
  virtual ~GeneralizeRequest();

  GeneralizeRequest(const GeneralizeRequest& from);

  inline GeneralizeRequest& operator=(const GeneralizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeneralizeRequest(GeneralizeRequest&& from) noexcept
    : GeneralizeRequest() {
    *this = ::std::move(from);
  }

  inline GeneralizeRequest& operator=(GeneralizeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralizeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralizeRequest* internal_default_instance() {
    return reinterpret_cast<const GeneralizeRequest*>(
               &_GeneralizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GeneralizeRequest* other);
  friend void swap(GeneralizeRequest& a, GeneralizeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeneralizeRequest* New() const final {
    return CreateMaybeMessage<GeneralizeRequest>(NULL);
  }

  GeneralizeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GeneralizeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GeneralizeRequest& from);
  void MergeFrom(const GeneralizeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneralizeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.GeneralizeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GeneralizeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.GeneralizeResponse) */ {
 public:
  GeneralizeResponse();
  virtual ~GeneralizeResponse();

  GeneralizeResponse(const GeneralizeResponse& from);

  inline GeneralizeResponse& operator=(const GeneralizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeneralizeResponse(GeneralizeResponse&& from) noexcept
    : GeneralizeResponse() {
    *this = ::std::move(from);
  }

  inline GeneralizeResponse& operator=(GeneralizeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralizeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralizeResponse* internal_default_instance() {
    return reinterpret_cast<const GeneralizeResponse*>(
               &_GeneralizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GeneralizeResponse* other);
  friend void swap(GeneralizeResponse& a, GeneralizeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeneralizeResponse* New() const final {
    return CreateMaybeMessage<GeneralizeResponse>(NULL);
  }

  GeneralizeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GeneralizeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GeneralizeResponse& from);
  void MergeFrom(const GeneralizeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneralizeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.GeneralizeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PeerHostInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.PeerHostInfo) */ {
 public:
  PeerHostInfo();
  virtual ~PeerHostInfo();

  PeerHostInfo(const PeerHostInfo& from);

  inline PeerHostInfo& operator=(const PeerHostInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerHostInfo(PeerHostInfo&& from) noexcept
    : PeerHostInfo() {
    *this = ::std::move(from);
  }

  inline PeerHostInfo& operator=(PeerHostInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerHostInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerHostInfo* internal_default_instance() {
    return reinterpret_cast<const PeerHostInfo*>(
               &_PeerHostInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(PeerHostInfo* other);
  friend void swap(PeerHostInfo& a, PeerHostInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerHostInfo* New() const final {
    return CreateMaybeMessage<PeerHostInfo>(NULL);
  }

  PeerHostInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PeerHostInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PeerHostInfo& from);
  void MergeFrom(const PeerHostInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerHostInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hostname = 1;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // int32 hostnum = 2;
  void clear_hostnum();
  static const int kHostnumFieldNumber = 2;
  ::google::protobuf::int32 hostnum() const;
  void set_hostnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.PeerHostInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::int32 hostnum_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPeerHostsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.GetPeerHostsRequest) */ {
 public:
  GetPeerHostsRequest();
  virtual ~GetPeerHostsRequest();

  GetPeerHostsRequest(const GetPeerHostsRequest& from);

  inline GetPeerHostsRequest& operator=(const GetPeerHostsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPeerHostsRequest(GetPeerHostsRequest&& from) noexcept
    : GetPeerHostsRequest() {
    *this = ::std::move(from);
  }

  inline GetPeerHostsRequest& operator=(GetPeerHostsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPeerHostsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPeerHostsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPeerHostsRequest*>(
               &_GetPeerHostsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(GetPeerHostsRequest* other);
  friend void swap(GetPeerHostsRequest& a, GetPeerHostsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPeerHostsRequest* New() const final {
    return CreateMaybeMessage<GetPeerHostsRequest>(NULL);
  }

  GetPeerHostsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetPeerHostsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetPeerHostsRequest& from);
  void MergeFrom(const GetPeerHostsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPeerHostsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vaultdb.PeerHostInfo hostnames = 1;
  int hostnames_size() const;
  void clear_hostnames();
  static const int kHostnamesFieldNumber = 1;
  ::vaultdb::PeerHostInfo* mutable_hostnames(int index);
  ::google::protobuf::RepeatedPtrField< ::vaultdb::PeerHostInfo >*
      mutable_hostnames();
  const ::vaultdb::PeerHostInfo& hostnames(int index) const;
  ::vaultdb::PeerHostInfo* add_hostnames();
  const ::google::protobuf::RepeatedPtrField< ::vaultdb::PeerHostInfo >&
      hostnames() const;

  // @@protoc_insertion_point(class_scope:vaultdb.GetPeerHostsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vaultdb::PeerHostInfo > hostnames_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPeerHostsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.GetPeerHostsResponse) */ {
 public:
  GetPeerHostsResponse();
  virtual ~GetPeerHostsResponse();

  GetPeerHostsResponse(const GetPeerHostsResponse& from);

  inline GetPeerHostsResponse& operator=(const GetPeerHostsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPeerHostsResponse(GetPeerHostsResponse&& from) noexcept
    : GetPeerHostsResponse() {
    *this = ::std::move(from);
  }

  inline GetPeerHostsResponse& operator=(GetPeerHostsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPeerHostsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPeerHostsResponse* internal_default_instance() {
    return reinterpret_cast<const GetPeerHostsResponse*>(
               &_GetPeerHostsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(GetPeerHostsResponse* other);
  friend void swap(GetPeerHostsResponse& a, GetPeerHostsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPeerHostsResponse* New() const final {
    return CreateMaybeMessage<GetPeerHostsResponse>(NULL);
  }

  GetPeerHostsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetPeerHostsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetPeerHostsResponse& from);
  void MergeFrom(const GetPeerHostsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPeerHostsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.GetPeerHostsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DBMSQueryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.DBMSQueryRequest) */ {
 public:
  DBMSQueryRequest();
  virtual ~DBMSQueryRequest();

  DBMSQueryRequest(const DBMSQueryRequest& from);

  inline DBMSQueryRequest& operator=(const DBMSQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DBMSQueryRequest(DBMSQueryRequest&& from) noexcept
    : DBMSQueryRequest() {
    *this = ::std::move(from);
  }

  inline DBMSQueryRequest& operator=(DBMSQueryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DBMSQueryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBMSQueryRequest* internal_default_instance() {
    return reinterpret_cast<const DBMSQueryRequest*>(
               &_DBMSQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(DBMSQueryRequest* other);
  friend void swap(DBMSQueryRequest& a, DBMSQueryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DBMSQueryRequest* New() const final {
    return CreateMaybeMessage<DBMSQueryRequest>(NULL);
  }

  DBMSQueryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DBMSQueryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DBMSQueryRequest& from);
  void MergeFrom(const DBMSQueryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBMSQueryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string dbname = 1;
  void clear_dbname();
  static const int kDbnameFieldNumber = 1;
  const ::std::string& dbname() const;
  void set_dbname(const ::std::string& value);
  #if LANG_CXX11
  void set_dbname(::std::string&& value);
  #endif
  void set_dbname(const char* value);
  void set_dbname(const char* value, size_t size);
  ::std::string* mutable_dbname();
  ::std::string* release_dbname();
  void set_allocated_dbname(::std::string* dbname);

  // string query = 2;
  void clear_query();
  static const int kQueryFieldNumber = 2;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // @@protoc_insertion_point(class_scope:vaultdb.DBMSQueryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dbname_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DBMSQueryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.DBMSQueryResponse) */ {
 public:
  DBMSQueryResponse();
  virtual ~DBMSQueryResponse();

  DBMSQueryResponse(const DBMSQueryResponse& from);

  inline DBMSQueryResponse& operator=(const DBMSQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DBMSQueryResponse(DBMSQueryResponse&& from) noexcept
    : DBMSQueryResponse() {
    *this = ::std::move(from);
  }

  inline DBMSQueryResponse& operator=(DBMSQueryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DBMSQueryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBMSQueryResponse* internal_default_instance() {
    return reinterpret_cast<const DBMSQueryResponse*>(
               &_DBMSQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(DBMSQueryResponse* other);
  friend void swap(DBMSQueryResponse& a, DBMSQueryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DBMSQueryResponse* New() const final {
    return CreateMaybeMessage<DBMSQueryResponse>(NULL);
  }

  DBMSQueryResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DBMSQueryResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DBMSQueryResponse& from);
  void MergeFrom(const DBMSQueryResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBMSQueryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vaultdb.TableID tableId = 1;
  bool has_tableid() const;
  void clear_tableid();
  static const int kTableIdFieldNumber = 1;
  private:
  const ::vaultdb::TableID& _internal_tableid() const;
  public:
  const ::vaultdb::TableID& tableid() const;
  ::vaultdb::TableID* release_tableid();
  ::vaultdb::TableID* mutable_tableid();
  void set_allocated_tableid(::vaultdb::TableID* tableid);

  // @@protoc_insertion_point(class_scope:vaultdb.DBMSQueryResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vaultdb::TableID* tableid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(RegisterRequest* other);
  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const final {
    return CreateMaybeMessage<RegisterRequest>(NULL);
  }

  RegisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hostname = 1;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:vaultdb.RegisterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(NULL);
  }

  RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 host_num = 1;
  void clear_host_num();
  static const int kHostNumFieldNumber = 1;
  ::google::protobuf::int32 host_num() const;
  void set_host_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.RegisterResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 host_num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NumHostsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.NumHostsRequest) */ {
 public:
  NumHostsRequest();
  virtual ~NumHostsRequest();

  NumHostsRequest(const NumHostsRequest& from);

  inline NumHostsRequest& operator=(const NumHostsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NumHostsRequest(NumHostsRequest&& from) noexcept
    : NumHostsRequest() {
    *this = ::std::move(from);
  }

  inline NumHostsRequest& operator=(NumHostsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NumHostsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NumHostsRequest* internal_default_instance() {
    return reinterpret_cast<const NumHostsRequest*>(
               &_NumHostsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(NumHostsRequest* other);
  friend void swap(NumHostsRequest& a, NumHostsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NumHostsRequest* New() const final {
    return CreateMaybeMessage<NumHostsRequest>(NULL);
  }

  NumHostsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NumHostsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NumHostsRequest& from);
  void MergeFrom(const NumHostsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumHostsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.NumHostsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NumHostResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.NumHostResp) */ {
 public:
  NumHostResp();
  virtual ~NumHostResp();

  NumHostResp(const NumHostResp& from);

  inline NumHostResp& operator=(const NumHostResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NumHostResp(NumHostResp&& from) noexcept
    : NumHostResp() {
    *this = ::std::move(from);
  }

  inline NumHostResp& operator=(NumHostResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NumHostResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NumHostResp* internal_default_instance() {
    return reinterpret_cast<const NumHostResp*>(
               &_NumHostResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(NumHostResp* other);
  friend void swap(NumHostResp& a, NumHostResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NumHostResp* New() const final {
    return CreateMaybeMessage<NumHostResp>(NULL);
  }

  NumHostResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NumHostResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NumHostResp& from);
  void MergeFrom(const NumHostResp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumHostResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 num_hosts = 1;
  void clear_num_hosts();
  static const int kNumHostsFieldNumber = 1;
  ::google::protobuf::int32 num_hosts() const;
  void set_num_hosts(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.NumHostResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 num_hosts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DBQueryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.DBQueryRequest) */ {
 public:
  DBQueryRequest();
  virtual ~DBQueryRequest();

  DBQueryRequest(const DBQueryRequest& from);

  inline DBQueryRequest& operator=(const DBQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DBQueryRequest(DBQueryRequest&& from) noexcept
    : DBQueryRequest() {
    *this = ::std::move(from);
  }

  inline DBQueryRequest& operator=(DBQueryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DBQueryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBQueryRequest* internal_default_instance() {
    return reinterpret_cast<const DBQueryRequest*>(
               &_DBQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(DBQueryRequest* other);
  friend void swap(DBQueryRequest& a, DBQueryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DBQueryRequest* New() const final {
    return CreateMaybeMessage<DBQueryRequest>(NULL);
  }

  DBQueryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DBQueryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DBQueryRequest& from);
  void MergeFrom(const DBQueryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBQueryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string query_string = 1;
  void clear_query_string();
  static const int kQueryStringFieldNumber = 1;
  const ::std::string& query_string() const;
  void set_query_string(const ::std::string& value);
  #if LANG_CXX11
  void set_query_string(::std::string&& value);
  #endif
  void set_query_string(const char* value);
  void set_query_string(const char* value, size_t size);
  ::std::string* mutable_query_string();
  ::std::string* release_query_string();
  void set_allocated_query_string(::std::string* query_string);

  // string dbname = 2;
  void clear_dbname();
  static const int kDbnameFieldNumber = 2;
  const ::std::string& dbname() const;
  void set_dbname(const ::std::string& value);
  #if LANG_CXX11
  void set_dbname(::std::string&& value);
  #endif
  void set_dbname(const char* value);
  void set_dbname(const char* value, size_t size);
  ::std::string* mutable_dbname();
  ::std::string* release_dbname();
  void set_allocated_dbname(::std::string* dbname);

  // @@protoc_insertion_point(class_scope:vaultdb.DBQueryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr query_string_;
  ::google::protobuf::internal::ArenaStringPtr dbname_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DBQueryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.DBQueryResponse) */ {
 public:
  DBQueryResponse();
  virtual ~DBQueryResponse();

  DBQueryResponse(const DBQueryResponse& from);

  inline DBQueryResponse& operator=(const DBQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DBQueryResponse(DBQueryResponse&& from) noexcept
    : DBQueryResponse() {
    *this = ::std::move(from);
  }

  inline DBQueryResponse& operator=(DBQueryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DBQueryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBQueryResponse* internal_default_instance() {
    return reinterpret_cast<const DBQueryResponse*>(
               &_DBQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(DBQueryResponse* other);
  friend void swap(DBQueryResponse& a, DBQueryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DBQueryResponse* New() const final {
    return CreateMaybeMessage<DBQueryResponse>(NULL);
  }

  DBQueryResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DBQueryResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DBQueryResponse& from);
  void MergeFrom(const DBQueryResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBQueryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string db_response = 1;
  void clear_db_response();
  static const int kDbResponseFieldNumber = 1;
  const ::std::string& db_response() const;
  void set_db_response(const ::std::string& value);
  #if LANG_CXX11
  void set_db_response(::std::string&& value);
  #endif
  void set_db_response(const char* value);
  void set_db_response(const char* value, size_t size);
  ::std::string* mutable_db_response();
  ::std::string* release_db_response();
  void set_allocated_db_response(::std::string* db_response);

  // @@protoc_insertion_point(class_scope:vaultdb.DBQueryResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_response_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.TableRequest) */ {
 public:
  TableRequest();
  virtual ~TableRequest();

  TableRequest(const TableRequest& from);

  inline TableRequest& operator=(const TableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableRequest(TableRequest&& from) noexcept
    : TableRequest() {
    *this = ::std::move(from);
  }

  inline TableRequest& operator=(TableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableRequest* internal_default_instance() {
    return reinterpret_cast<const TableRequest*>(
               &_TableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(TableRequest* other);
  friend void swap(TableRequest& a, TableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableRequest* New() const final {
    return CreateMaybeMessage<TableRequest>(NULL);
  }

  TableRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableRequest& from);
  void MergeFrom(const TableRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vaultdb.TableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.TableResponse) */ {
 public:
  TableResponse();
  virtual ~TableResponse();

  TableResponse(const TableResponse& from);

  inline TableResponse& operator=(const TableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableResponse(TableResponse&& from) noexcept
    : TableResponse() {
    *this = ::std::move(from);
  }

  inline TableResponse& operator=(TableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableResponse* internal_default_instance() {
    return reinterpret_cast<const TableResponse*>(
               &_TableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(TableResponse* other);
  friend void swap(TableResponse& a, TableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableResponse* New() const final {
    return CreateMaybeMessage<TableResponse>(NULL);
  }

  TableResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableResponse& from);
  void MergeFrom(const TableResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vaultdb.Table t = 1;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 1;
  private:
  const ::vaultdb::Table& _internal_t() const;
  public:
  const ::vaultdb::Table& t() const;
  ::vaultdb::Table* release_t();
  ::vaultdb::Table* mutable_t();
  void set_allocated_t(::vaultdb::Table* t);

  // @@protoc_insertion_point(class_scope:vaultdb.TableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vaultdb::Table* t_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class schema : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.schema) */ {
 public:
  schema();
  virtual ~schema();

  schema(const schema& from);

  inline schema& operator=(const schema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  schema(schema&& from) noexcept
    : schema() {
    *this = ::std::move(from);
  }

  inline schema& operator=(schema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const schema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const schema* internal_default_instance() {
    return reinterpret_cast<const schema*>(
               &_schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(schema* other);
  friend void swap(schema& a, schema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline schema* New() const final {
    return CreateMaybeMessage<schema>(NULL);
  }

  schema* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<schema>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const schema& from);
  void MergeFrom(const schema& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(schema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vaultdb.Table q = 2;
  int q_size() const;
  void clear_q();
  static const int kQFieldNumber = 2;
  ::vaultdb::Table* mutable_q(int index);
  ::google::protobuf::RepeatedPtrField< ::vaultdb::Table >*
      mutable_q();
  const ::vaultdb::Table& q(int index) const;
  ::vaultdb::Table* add_q();
  const ::google::protobuf::RepeatedPtrField< ::vaultdb::Table >&
      q() const;

  // @@protoc_insertion_point(class_scope:vaultdb.schema)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vaultdb::Table > q_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableStream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.TableStream) */ {
 public:
  TableStream();
  virtual ~TableStream();

  TableStream(const TableStream& from);

  inline TableStream& operator=(const TableStream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableStream(TableStream&& from) noexcept
    : TableStream() {
    *this = ::std::move(from);
  }

  inline TableStream& operator=(TableStream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableStream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableStream* internal_default_instance() {
    return reinterpret_cast<const TableStream*>(
               &_TableStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(TableStream* other);
  friend void swap(TableStream& a, TableStream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableStream* New() const final {
    return CreateMaybeMessage<TableStream>(NULL);
  }

  TableStream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableStream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableStream& from);
  void MergeFrom(const TableStream& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableStream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes page = 4;
  void clear_page();
  static const int kPageFieldNumber = 4;
  const ::std::string& page() const;
  void set_page(const ::std::string& value);
  #if LANG_CXX11
  void set_page(::std::string&& value);
  #endif
  void set_page(const char* value);
  void set_page(const void* value, size_t size);
  ::std::string* mutable_page();
  ::std::string* release_page();
  void set_allocated_page(::std::string* page);

  // .vaultdb.Table t = 1;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 1;
  private:
  const ::vaultdb::Table& _internal_t() const;
  public:
  const ::vaultdb::Table& t() const;
  ::vaultdb::Table* release_t();
  ::vaultdb::Table* mutable_t();
  void set_allocated_t(::vaultdb::Table* t);

  // int32 page_no = 3;
  void clear_page_no();
  static const int kPageNoFieldNumber = 3;
  ::google::protobuf::int32 page_no() const;
  void set_page_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.TableStream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr page_;
  ::vaultdb::Table* t_;
  ::google::protobuf::int32 page_no_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Table : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.Table) */ {
 public:
  Table();
  virtual ~Table();

  Table(const Table& from);

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(Table&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Table& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(Table* other);
  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Table* New() const final {
    return CreateMaybeMessage<Table>(NULL);
  }

  Table* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Table& from);
  void MergeFrom(const Table& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes schema = 4;
  void clear_schema();
  static const int kSchemaFieldNumber = 4;
  const ::std::string& schema() const;
  void set_schema(const ::std::string& value);
  #if LANG_CXX11
  void set_schema(::std::string&& value);
  #endif
  void set_schema(const char* value);
  void set_schema(const void* value, size_t size);
  ::std::string* mutable_schema();
  ::std::string* release_schema();
  void set_allocated_schema(::std::string* schema);

  // int32 num_tuple_pages = 1;
  void clear_num_tuple_pages();
  static const int kNumTuplePagesFieldNumber = 1;
  ::google::protobuf::int32 num_tuple_pages() const;
  void set_num_tuple_pages(::google::protobuf::int32 value);

  // int32 num_tuples = 2;
  void clear_num_tuples();
  static const int kNumTuplesFieldNumber = 2;
  ::google::protobuf::int32 num_tuples() const;
  void set_num_tuples(::google::protobuf::int32 value);

  // int32 size_of_tuple = 3;
  void clear_size_of_tuple();
  static const int kSizeOfTupleFieldNumber = 3;
  ::google::protobuf::int32 size_of_tuple() const;
  void set_size_of_tuple(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.Table)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr schema_;
  ::google::protobuf::int32 num_tuple_pages_;
  ::google::protobuf::int32 num_tuples_;
  ::google::protobuf::int32 size_of_tuple_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TuplePage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.TuplePage) */ {
 public:
  TuplePage();
  virtual ~TuplePage();

  TuplePage(const TuplePage& from);

  inline TuplePage& operator=(const TuplePage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TuplePage(TuplePage&& from) noexcept
    : TuplePage() {
    *this = ::std::move(from);
  }

  inline TuplePage& operator=(TuplePage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TuplePage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TuplePage* internal_default_instance() {
    return reinterpret_cast<const TuplePage*>(
               &_TuplePage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(TuplePage* other);
  friend void swap(TuplePage& a, TuplePage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TuplePage* New() const final {
    return CreateMaybeMessage<TuplePage>(NULL);
  }

  TuplePage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TuplePage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TuplePage& from);
  void MergeFrom(const TuplePage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TuplePage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes page = 2;
  void clear_page();
  static const int kPageFieldNumber = 2;
  const ::std::string& page() const;
  void set_page(const ::std::string& value);
  #if LANG_CXX11
  void set_page(::std::string&& value);
  #endif
  void set_page(const char* value);
  void set_page(const void* value, size_t size);
  ::std::string* mutable_page();
  ::std::string* release_page();
  void set_allocated_page(::std::string* page);

  // int32 page_no = 1;
  void clear_page_no();
  static const int kPageNoFieldNumber = 1;
  ::google::protobuf::int32 page_no() const;
  void set_page_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.TuplePage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr page_;
  ::google::protobuf::int32 page_no_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FieldDesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.FieldDesc) */ {
 public:
  FieldDesc();
  virtual ~FieldDesc();

  FieldDesc(const FieldDesc& from);

  inline FieldDesc& operator=(const FieldDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FieldDesc(FieldDesc&& from) noexcept
    : FieldDesc() {
    *this = ::std::move(from);
  }

  inline FieldDesc& operator=(FieldDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldDesc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FieldDesc* internal_default_instance() {
    return reinterpret_cast<const FieldDesc*>(
               &_FieldDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(FieldDesc* other);
  friend void swap(FieldDesc& a, FieldDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FieldDesc* New() const final {
    return CreateMaybeMessage<FieldDesc>(NULL);
  }

  FieldDesc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FieldDesc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FieldDesc& from);
  void MergeFrom(const FieldDesc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FieldDesc_FieldType FieldType;
  static const FieldType UNSUPPORTED =
    FieldDesc_FieldType_UNSUPPORTED;
  static const FieldType FIXEDCHAR =
    FieldDesc_FieldType_FIXEDCHAR;
  static const FieldType INT =
    FieldDesc_FieldType_INT;
  static inline bool FieldType_IsValid(int value) {
    return FieldDesc_FieldType_IsValid(value);
  }
  static const FieldType FieldType_MIN =
    FieldDesc_FieldType_FieldType_MIN;
  static const FieldType FieldType_MAX =
    FieldDesc_FieldType_FieldType_MAX;
  static const int FieldType_ARRAYSIZE =
    FieldDesc_FieldType_FieldType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FieldType_descriptor() {
    return FieldDesc_FieldType_descriptor();
  }
  static inline const ::std::string& FieldType_Name(FieldType value) {
    return FieldDesc_FieldType_Name(value);
  }
  static inline bool FieldType_Parse(const ::std::string& name,
      FieldType* value) {
    return FieldDesc_FieldType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string field_name = 1;
  void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  const ::std::string& field_name() const;
  void set_field_name(const ::std::string& value);
  #if LANG_CXX11
  void set_field_name(::std::string&& value);
  #endif
  void set_field_name(const char* value);
  void set_field_name(const char* value, size_t size);
  ::std::string* mutable_field_name();
  ::std::string* release_field_name();
  void set_allocated_field_name(::std::string* field_name);

  // int32 col_no = 2;
  void clear_col_no();
  static const int kColNoFieldNumber = 2;
  ::google::protobuf::int32 col_no() const;
  void set_col_no(::google::protobuf::int32 value);

  // .vaultdb.FieldDesc.FieldType field_type = 3;
  void clear_field_type();
  static const int kFieldTypeFieldNumber = 3;
  ::vaultdb::FieldDesc_FieldType field_type() const;
  void set_field_type(::vaultdb::FieldDesc_FieldType value);

  // @@protoc_insertion_point(class_scope:vaultdb.FieldDesc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr field_name_;
  ::google::protobuf::int32 col_no_;
  int field_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Schema : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.Schema) */ {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(Schema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Schema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(Schema* other);
  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Schema* New() const final {
    return CreateMaybeMessage<Schema>(NULL);
  }

  Schema* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vaultdb.FieldDesc field = 2;
  int field_size() const;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  ::vaultdb::FieldDesc* mutable_field(int index);
  ::google::protobuf::RepeatedPtrField< ::vaultdb::FieldDesc >*
      mutable_field();
  const ::vaultdb::FieldDesc& field(int index) const;
  ::vaultdb::FieldDesc* add_field();
  const ::google::protobuf::RepeatedPtrField< ::vaultdb::FieldDesc >&
      field() const;

  // int32 num_fields = 1;
  void clear_num_fields();
  static const int kNumFieldsFieldNumber = 1;
  ::google::protobuf::int32 num_fields() const;
  void set_num_fields(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.Schema)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vaultdb::FieldDesc > field_;
  ::google::protobuf::int32 num_fields_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableQueryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.TableQueryRequest) */ {
 public:
  TableQueryRequest();
  virtual ~TableQueryRequest();

  TableQueryRequest(const TableQueryRequest& from);

  inline TableQueryRequest& operator=(const TableQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableQueryRequest(TableQueryRequest&& from) noexcept
    : TableQueryRequest() {
    *this = ::std::move(from);
  }

  inline TableQueryRequest& operator=(TableQueryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableQueryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableQueryRequest* internal_default_instance() {
    return reinterpret_cast<const TableQueryRequest*>(
               &_TableQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(TableQueryRequest* other);
  friend void swap(TableQueryRequest& a, TableQueryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableQueryRequest* New() const final {
    return CreateMaybeMessage<TableQueryRequest>(NULL);
  }

  TableQueryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableQueryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableQueryRequest& from);
  void MergeFrom(const TableQueryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableQueryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string dbname = 1;
  void clear_dbname();
  static const int kDbnameFieldNumber = 1;
  const ::std::string& dbname() const;
  void set_dbname(const ::std::string& value);
  #if LANG_CXX11
  void set_dbname(::std::string&& value);
  #endif
  void set_dbname(const char* value);
  void set_dbname(const char* value, size_t size);
  ::std::string* mutable_dbname();
  ::std::string* release_dbname();
  void set_allocated_dbname(::std::string* dbname);

  // string query = 2;
  void clear_query();
  static const int kQueryFieldNumber = 2;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // @@protoc_insertion_point(class_scope:vaultdb.TableQueryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dbname_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableQueryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vaultdb.TableQueryResponse) */ {
 public:
  TableQueryResponse();
  virtual ~TableQueryResponse();

  TableQueryResponse(const TableQueryResponse& from);

  inline TableQueryResponse& operator=(const TableQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableQueryResponse(TableQueryResponse&& from) noexcept
    : TableQueryResponse() {
    *this = ::std::move(from);
  }

  inline TableQueryResponse& operator=(TableQueryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableQueryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableQueryResponse* internal_default_instance() {
    return reinterpret_cast<const TableQueryResponse*>(
               &_TableQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(TableQueryResponse* other);
  friend void swap(TableQueryResponse& a, TableQueryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableQueryResponse* New() const final {
    return CreateMaybeMessage<TableQueryResponse>(NULL);
  }

  TableQueryResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableQueryResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableQueryResponse& from);
  void MergeFrom(const TableQueryResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableQueryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes page = 8;
  void clear_page();
  static const int kPageFieldNumber = 8;
  const ::std::string& page() const;
  void set_page(const ::std::string& value);
  #if LANG_CXX11
  void set_page(::std::string&& value);
  #endif
  void set_page(const char* value);
  void set_page(const void* value, size_t size);
  ::std::string* mutable_page();
  ::std::string* release_page();
  void set_allocated_page(::std::string* page);

  // .vaultdb.Schema schema = 3;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 3;
  private:
  const ::vaultdb::Schema& _internal_schema() const;
  public:
  const ::vaultdb::Schema& schema() const;
  ::vaultdb::Schema* release_schema();
  ::vaultdb::Schema* mutable_schema();
  void set_allocated_schema(::vaultdb::Schema* schema);

  // bool is_header = 2;
  void clear_is_header();
  static const int kIsHeaderFieldNumber = 2;
  bool is_header() const;
  void set_is_header(bool value);

  // int32 num_tuples = 4;
  void clear_num_tuples();
  static const int kNumTuplesFieldNumber = 4;
  ::google::protobuf::int32 num_tuples() const;
  void set_num_tuples(::google::protobuf::int32 value);

  // int32 size_of_tuple = 5;
  void clear_size_of_tuple();
  static const int kSizeOfTupleFieldNumber = 5;
  ::google::protobuf::int32 size_of_tuple() const;
  void set_size_of_tuple(::google::protobuf::int32 value);

  // int32 num_tuple_pages = 6;
  void clear_num_tuple_pages();
  static const int kNumTuplePagesFieldNumber = 6;
  ::google::protobuf::int32 num_tuple_pages() const;
  void set_num_tuple_pages(::google::protobuf::int32 value);

  // int32 page_no = 7;
  void clear_page_no();
  static const int kPageNoFieldNumber = 7;
  ::google::protobuf::int32 page_no() const;
  void set_page_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vaultdb.TableQueryResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr page_;
  ::vaultdb::Schema* schema_;
  bool is_header_;
  ::google::protobuf::int32 num_tuples_;
  ::google::protobuf::int32 size_of_tuple_;
  ::google::protobuf::int32 num_tuple_pages_;
  ::google::protobuf::int32 page_no_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vaultdb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CoaleseTablesRequest

// repeated .vaultdb.TableID tablefragments = 1;
inline int CoaleseTablesRequest::tablefragments_size() const {
  return tablefragments_.size();
}
inline void CoaleseTablesRequest::clear_tablefragments() {
  tablefragments_.Clear();
}
inline ::vaultdb::TableID* CoaleseTablesRequest::mutable_tablefragments(int index) {
  // @@protoc_insertion_point(field_mutable:vaultdb.CoaleseTablesRequest.tablefragments)
  return tablefragments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >*
CoaleseTablesRequest::mutable_tablefragments() {
  // @@protoc_insertion_point(field_mutable_list:vaultdb.CoaleseTablesRequest.tablefragments)
  return &tablefragments_;
}
inline const ::vaultdb::TableID& CoaleseTablesRequest::tablefragments(int index) const {
  // @@protoc_insertion_point(field_get:vaultdb.CoaleseTablesRequest.tablefragments)
  return tablefragments_.Get(index);
}
inline ::vaultdb::TableID* CoaleseTablesRequest::add_tablefragments() {
  // @@protoc_insertion_point(field_add:vaultdb.CoaleseTablesRequest.tablefragments)
  return tablefragments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >&
CoaleseTablesRequest::tablefragments() const {
  // @@protoc_insertion_point(field_list:vaultdb.CoaleseTablesRequest.tablefragments)
  return tablefragments_;
}

// -------------------------------------------------------------------

// CoaleseTablesResponse

// .vaultdb.TableID id = 1;
inline bool CoaleseTablesResponse::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void CoaleseTablesResponse::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::vaultdb::TableID& CoaleseTablesResponse::_internal_id() const {
  return *id_;
}
inline const ::vaultdb::TableID& CoaleseTablesResponse::id() const {
  const ::vaultdb::TableID* p = id_;
  // @@protoc_insertion_point(field_get:vaultdb.CoaleseTablesResponse.id)
  return p != NULL ? *p : *reinterpret_cast<const ::vaultdb::TableID*>(
      &::vaultdb::_TableID_default_instance_);
}
inline ::vaultdb::TableID* CoaleseTablesResponse::release_id() {
  // @@protoc_insertion_point(field_release:vaultdb.CoaleseTablesResponse.id)
  
  ::vaultdb::TableID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::vaultdb::TableID* CoaleseTablesResponse::mutable_id() {
  
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::vaultdb::TableID>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vaultdb.CoaleseTablesResponse.id)
  return id_;
}
inline void CoaleseTablesResponse::set_allocated_id(::vaultdb::TableID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:vaultdb.CoaleseTablesResponse.id)
}

// -------------------------------------------------------------------

// GetControlFlowColumnRequest

// -------------------------------------------------------------------

// GetControlFlowColumnResponse

// .vaultdb.ControlFlowColumn cf = 1;
inline bool GetControlFlowColumnResponse::has_cf() const {
  return this != internal_default_instance() && cf_ != NULL;
}
inline void GetControlFlowColumnResponse::clear_cf() {
  if (GetArenaNoVirtual() == NULL && cf_ != NULL) {
    delete cf_;
  }
  cf_ = NULL;
}
inline const ::vaultdb::ControlFlowColumn& GetControlFlowColumnResponse::_internal_cf() const {
  return *cf_;
}
inline const ::vaultdb::ControlFlowColumn& GetControlFlowColumnResponse::cf() const {
  const ::vaultdb::ControlFlowColumn* p = cf_;
  // @@protoc_insertion_point(field_get:vaultdb.GetControlFlowColumnResponse.cf)
  return p != NULL ? *p : *reinterpret_cast<const ::vaultdb::ControlFlowColumn*>(
      &::vaultdb::_ControlFlowColumn_default_instance_);
}
inline ::vaultdb::ControlFlowColumn* GetControlFlowColumnResponse::release_cf() {
  // @@protoc_insertion_point(field_release:vaultdb.GetControlFlowColumnResponse.cf)
  
  ::vaultdb::ControlFlowColumn* temp = cf_;
  cf_ = NULL;
  return temp;
}
inline ::vaultdb::ControlFlowColumn* GetControlFlowColumnResponse::mutable_cf() {
  
  if (cf_ == NULL) {
    auto* p = CreateMaybeMessage<::vaultdb::ControlFlowColumn>(GetArenaNoVirtual());
    cf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vaultdb.GetControlFlowColumnResponse.cf)
  return cf_;
}
inline void GetControlFlowColumnResponse::set_allocated_cf(::vaultdb::ControlFlowColumn* cf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cf_;
  }
  if (cf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cf, submessage_arena);
    }
    
  } else {
    
  }
  cf_ = cf;
  // @@protoc_insertion_point(field_set_allocated:vaultdb.GetControlFlowColumnResponse.cf)
}

// -------------------------------------------------------------------

// ControlFlowColumn

// int32 cfid = 1;
inline void ControlFlowColumn::clear_cfid() {
  cfid_ = 0;
}
inline ::google::protobuf::int32 ControlFlowColumn::cfid() const {
  // @@protoc_insertion_point(field_get:vaultdb.ControlFlowColumn.cfid)
  return cfid_;
}
inline void ControlFlowColumn::set_cfid(::google::protobuf::int32 value) {
  
  cfid_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.ControlFlowColumn.cfid)
}

// -------------------------------------------------------------------

// RepartitionStepTwoRequest

// repeated .vaultdb.TableID tablefragments = 1;
inline int RepartitionStepTwoRequest::tablefragments_size() const {
  return tablefragments_.size();
}
inline void RepartitionStepTwoRequest::clear_tablefragments() {
  tablefragments_.Clear();
}
inline ::vaultdb::TableID* RepartitionStepTwoRequest::mutable_tablefragments(int index) {
  // @@protoc_insertion_point(field_mutable:vaultdb.RepartitionStepTwoRequest.tablefragments)
  return tablefragments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >*
RepartitionStepTwoRequest::mutable_tablefragments() {
  // @@protoc_insertion_point(field_mutable_list:vaultdb.RepartitionStepTwoRequest.tablefragments)
  return &tablefragments_;
}
inline const ::vaultdb::TableID& RepartitionStepTwoRequest::tablefragments(int index) const {
  // @@protoc_insertion_point(field_get:vaultdb.RepartitionStepTwoRequest.tablefragments)
  return tablefragments_.Get(index);
}
inline ::vaultdb::TableID* RepartitionStepTwoRequest::add_tablefragments() {
  // @@protoc_insertion_point(field_add:vaultdb.RepartitionStepTwoRequest.tablefragments)
  return tablefragments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >&
RepartitionStepTwoRequest::tablefragments() const {
  // @@protoc_insertion_point(field_list:vaultdb.RepartitionStepTwoRequest.tablefragments)
  return tablefragments_;
}

// -------------------------------------------------------------------

// RepartitionStepTwoResponse

// repeated .vaultdb.TableID remoteRepartitionIDs = 1;
inline int RepartitionStepTwoResponse::remoterepartitionids_size() const {
  return remoterepartitionids_.size();
}
inline void RepartitionStepTwoResponse::clear_remoterepartitionids() {
  remoterepartitionids_.Clear();
}
inline ::vaultdb::TableID* RepartitionStepTwoResponse::mutable_remoterepartitionids(int index) {
  // @@protoc_insertion_point(field_mutable:vaultdb.RepartitionStepTwoResponse.remoteRepartitionIDs)
  return remoterepartitionids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >*
RepartitionStepTwoResponse::mutable_remoterepartitionids() {
  // @@protoc_insertion_point(field_mutable_list:vaultdb.RepartitionStepTwoResponse.remoteRepartitionIDs)
  return &remoterepartitionids_;
}
inline const ::vaultdb::TableID& RepartitionStepTwoResponse::remoterepartitionids(int index) const {
  // @@protoc_insertion_point(field_get:vaultdb.RepartitionStepTwoResponse.remoteRepartitionIDs)
  return remoterepartitionids_.Get(index);
}
inline ::vaultdb::TableID* RepartitionStepTwoResponse::add_remoterepartitionids() {
  // @@protoc_insertion_point(field_add:vaultdb.RepartitionStepTwoResponse.remoteRepartitionIDs)
  return remoterepartitionids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >&
RepartitionStepTwoResponse::remoterepartitionids() const {
  // @@protoc_insertion_point(field_list:vaultdb.RepartitionStepTwoResponse.remoteRepartitionIDs)
  return remoterepartitionids_;
}

// -------------------------------------------------------------------

// RepartitionStepOneRequest

// .vaultdb.TableID tableid = 1;
inline bool RepartitionStepOneRequest::has_tableid() const {
  return this != internal_default_instance() && tableid_ != NULL;
}
inline void RepartitionStepOneRequest::clear_tableid() {
  if (GetArenaNoVirtual() == NULL && tableid_ != NULL) {
    delete tableid_;
  }
  tableid_ = NULL;
}
inline const ::vaultdb::TableID& RepartitionStepOneRequest::_internal_tableid() const {
  return *tableid_;
}
inline const ::vaultdb::TableID& RepartitionStepOneRequest::tableid() const {
  const ::vaultdb::TableID* p = tableid_;
  // @@protoc_insertion_point(field_get:vaultdb.RepartitionStepOneRequest.tableid)
  return p != NULL ? *p : *reinterpret_cast<const ::vaultdb::TableID*>(
      &::vaultdb::_TableID_default_instance_);
}
inline ::vaultdb::TableID* RepartitionStepOneRequest::release_tableid() {
  // @@protoc_insertion_point(field_release:vaultdb.RepartitionStepOneRequest.tableid)
  
  ::vaultdb::TableID* temp = tableid_;
  tableid_ = NULL;
  return temp;
}
inline ::vaultdb::TableID* RepartitionStepOneRequest::mutable_tableid() {
  
  if (tableid_ == NULL) {
    auto* p = CreateMaybeMessage<::vaultdb::TableID>(GetArenaNoVirtual());
    tableid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vaultdb.RepartitionStepOneRequest.tableid)
  return tableid_;
}
inline void RepartitionStepOneRequest::set_allocated_tableid(::vaultdb::TableID* tableid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tableid_;
  }
  if (tableid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tableid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tableid, submessage_arena);
    }
    
  } else {
    
  }
  tableid_ = tableid;
  // @@protoc_insertion_point(field_set_allocated:vaultdb.RepartitionStepOneRequest.tableid)
}

// -------------------------------------------------------------------

// TableID

// string dbname = 1;
inline void TableID::clear_dbname() {
  dbname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableID::dbname() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableID.dbname)
  return dbname_.GetNoArena();
}
inline void TableID::set_dbname(const ::std::string& value) {
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.TableID.dbname)
}
#if LANG_CXX11
inline void TableID::set_dbname(::std::string&& value) {
  
  dbname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.TableID.dbname)
}
#endif
inline void TableID::set_dbname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.TableID.dbname)
}
inline void TableID::set_dbname(const char* value, size_t size) {
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.TableID.dbname)
}
inline ::std::string* TableID::mutable_dbname() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.TableID.dbname)
  return dbname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableID::release_dbname() {
  // @@protoc_insertion_point(field_release:vaultdb.TableID.dbname)
  
  return dbname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableID::set_allocated_dbname(::std::string* dbname) {
  if (dbname != NULL) {
    
  } else {
    
  }
  dbname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dbname);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableID.dbname)
}

// string query = 2;
inline void TableID::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableID::query() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableID.query)
  return query_.GetNoArena();
}
inline void TableID::set_query(const ::std::string& value) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.TableID.query)
}
#if LANG_CXX11
inline void TableID::set_query(::std::string&& value) {
  
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.TableID.query)
}
#endif
inline void TableID::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.TableID.query)
}
inline void TableID::set_query(const char* value, size_t size) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.TableID.query)
}
inline ::std::string* TableID::mutable_query() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.TableID.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableID::release_query() {
  // @@protoc_insertion_point(field_release:vaultdb.TableID.query)
  
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableID::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    
  } else {
    
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableID.query)
}

// int32 hostnum = 3;
inline void TableID::clear_hostnum() {
  hostnum_ = 0;
}
inline ::google::protobuf::int32 TableID::hostnum() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableID.hostnum)
  return hostnum_;
}
inline void TableID::set_hostnum(::google::protobuf::int32 value) {
  
  hostnum_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TableID.hostnum)
}

// int32 tableid = 4;
inline void TableID::clear_tableid() {
  tableid_ = 0;
}
inline ::google::protobuf::int32 TableID::tableid() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableID.tableid)
  return tableid_;
}
inline void TableID::set_tableid(::google::protobuf::int32 value) {
  
  tableid_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TableID.tableid)
}

// -------------------------------------------------------------------

// RepartitionStepOneResponse

// repeated .vaultdb.TableID remoteRepartitionIDs = 1;
inline int RepartitionStepOneResponse::remoterepartitionids_size() const {
  return remoterepartitionids_.size();
}
inline void RepartitionStepOneResponse::clear_remoterepartitionids() {
  remoterepartitionids_.Clear();
}
inline ::vaultdb::TableID* RepartitionStepOneResponse::mutable_remoterepartitionids(int index) {
  // @@protoc_insertion_point(field_mutable:vaultdb.RepartitionStepOneResponse.remoteRepartitionIDs)
  return remoterepartitionids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >*
RepartitionStepOneResponse::mutable_remoterepartitionids() {
  // @@protoc_insertion_point(field_mutable_list:vaultdb.RepartitionStepOneResponse.remoteRepartitionIDs)
  return &remoterepartitionids_;
}
inline const ::vaultdb::TableID& RepartitionStepOneResponse::remoterepartitionids(int index) const {
  // @@protoc_insertion_point(field_get:vaultdb.RepartitionStepOneResponse.remoteRepartitionIDs)
  return remoterepartitionids_.Get(index);
}
inline ::vaultdb::TableID* RepartitionStepOneResponse::add_remoterepartitionids() {
  // @@protoc_insertion_point(field_add:vaultdb.RepartitionStepOneResponse.remoteRepartitionIDs)
  return remoterepartitionids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vaultdb::TableID >&
RepartitionStepOneResponse::remoterepartitionids() const {
  // @@protoc_insertion_point(field_list:vaultdb.RepartitionStepOneResponse.remoteRepartitionIDs)
  return remoterepartitionids_;
}

// -------------------------------------------------------------------

// SendTableRequest

// bool is_header = 2;
inline void SendTableRequest::clear_is_header() {
  is_header_ = false;
}
inline bool SendTableRequest::is_header() const {
  // @@protoc_insertion_point(field_get:vaultdb.SendTableRequest.is_header)
  return is_header_;
}
inline void SendTableRequest::set_is_header(bool value) {
  
  is_header_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.SendTableRequest.is_header)
}

// .vaultdb.Schema schema = 3;
inline bool SendTableRequest::has_schema() const {
  return this != internal_default_instance() && schema_ != NULL;
}
inline void SendTableRequest::clear_schema() {
  if (GetArenaNoVirtual() == NULL && schema_ != NULL) {
    delete schema_;
  }
  schema_ = NULL;
}
inline const ::vaultdb::Schema& SendTableRequest::_internal_schema() const {
  return *schema_;
}
inline const ::vaultdb::Schema& SendTableRequest::schema() const {
  const ::vaultdb::Schema* p = schema_;
  // @@protoc_insertion_point(field_get:vaultdb.SendTableRequest.schema)
  return p != NULL ? *p : *reinterpret_cast<const ::vaultdb::Schema*>(
      &::vaultdb::_Schema_default_instance_);
}
inline ::vaultdb::Schema* SendTableRequest::release_schema() {
  // @@protoc_insertion_point(field_release:vaultdb.SendTableRequest.schema)
  
  ::vaultdb::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline ::vaultdb::Schema* SendTableRequest::mutable_schema() {
  
  if (schema_ == NULL) {
    auto* p = CreateMaybeMessage<::vaultdb::Schema>(GetArenaNoVirtual());
    schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vaultdb.SendTableRequest.schema)
  return schema_;
}
inline void SendTableRequest::set_allocated_schema(::vaultdb::Schema* schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete schema_;
  }
  if (schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:vaultdb.SendTableRequest.schema)
}

// int32 num_tuples = 4;
inline void SendTableRequest::clear_num_tuples() {
  num_tuples_ = 0;
}
inline ::google::protobuf::int32 SendTableRequest::num_tuples() const {
  // @@protoc_insertion_point(field_get:vaultdb.SendTableRequest.num_tuples)
  return num_tuples_;
}
inline void SendTableRequest::set_num_tuples(::google::protobuf::int32 value) {
  
  num_tuples_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.SendTableRequest.num_tuples)
}

// int32 size_of_tuple = 5;
inline void SendTableRequest::clear_size_of_tuple() {
  size_of_tuple_ = 0;
}
inline ::google::protobuf::int32 SendTableRequest::size_of_tuple() const {
  // @@protoc_insertion_point(field_get:vaultdb.SendTableRequest.size_of_tuple)
  return size_of_tuple_;
}
inline void SendTableRequest::set_size_of_tuple(::google::protobuf::int32 value) {
  
  size_of_tuple_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.SendTableRequest.size_of_tuple)
}

// int32 num_tuple_pages = 6;
inline void SendTableRequest::clear_num_tuple_pages() {
  num_tuple_pages_ = 0;
}
inline ::google::protobuf::int32 SendTableRequest::num_tuple_pages() const {
  // @@protoc_insertion_point(field_get:vaultdb.SendTableRequest.num_tuple_pages)
  return num_tuple_pages_;
}
inline void SendTableRequest::set_num_tuple_pages(::google::protobuf::int32 value) {
  
  num_tuple_pages_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.SendTableRequest.num_tuple_pages)
}

// int32 page_no = 7;
inline void SendTableRequest::clear_page_no() {
  page_no_ = 0;
}
inline ::google::protobuf::int32 SendTableRequest::page_no() const {
  // @@protoc_insertion_point(field_get:vaultdb.SendTableRequest.page_no)
  return page_no_;
}
inline void SendTableRequest::set_page_no(::google::protobuf::int32 value) {
  
  page_no_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.SendTableRequest.page_no)
}

// bytes page = 8;
inline void SendTableRequest::clear_page() {
  page_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendTableRequest::page() const {
  // @@protoc_insertion_point(field_get:vaultdb.SendTableRequest.page)
  return page_.GetNoArena();
}
inline void SendTableRequest::set_page(const ::std::string& value) {
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.SendTableRequest.page)
}
#if LANG_CXX11
inline void SendTableRequest::set_page(::std::string&& value) {
  
  page_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.SendTableRequest.page)
}
#endif
inline void SendTableRequest::set_page(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.SendTableRequest.page)
}
inline void SendTableRequest::set_page(const void* value, size_t size) {
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.SendTableRequest.page)
}
inline ::std::string* SendTableRequest::mutable_page() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.SendTableRequest.page)
  return page_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendTableRequest::release_page() {
  // @@protoc_insertion_point(field_release:vaultdb.SendTableRequest.page)
  
  return page_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendTableRequest::set_allocated_page(::std::string* page) {
  if (page != NULL) {
    
  } else {
    
  }
  page_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.SendTableRequest.page)
}

// -------------------------------------------------------------------

// SendTableResponse

// int32 tableID = 1;
inline void SendTableResponse::clear_tableid() {
  tableid_ = 0;
}
inline ::google::protobuf::int32 SendTableResponse::tableid() const {
  // @@protoc_insertion_point(field_get:vaultdb.SendTableResponse.tableID)
  return tableid_;
}
inline void SendTableResponse::set_tableid(::google::protobuf::int32 value) {
  
  tableid_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.SendTableResponse.tableID)
}

// -------------------------------------------------------------------

// KFilterRequest

// int32 tableID = 1;
inline void KFilterRequest::clear_tableid() {
  tableid_ = 0;
}
inline ::google::protobuf::int32 KFilterRequest::tableid() const {
  // @@protoc_insertion_point(field_get:vaultdb.KFilterRequest.tableID)
  return tableid_;
}
inline void KFilterRequest::set_tableid(::google::protobuf::int32 value) {
  
  tableid_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.KFilterRequest.tableID)
}

// -------------------------------------------------------------------

// KFilterResponse

// -------------------------------------------------------------------

// KJoinRequest

// -------------------------------------------------------------------

// KJoinResponse

// -------------------------------------------------------------------

// KSortRequest

// -------------------------------------------------------------------

// KSortResponse

// -------------------------------------------------------------------

// GeneralizeRequest

// -------------------------------------------------------------------

// GeneralizeResponse

// -------------------------------------------------------------------

// PeerHostInfo

// string hostname = 1;
inline void PeerHostInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerHostInfo::hostname() const {
  // @@protoc_insertion_point(field_get:vaultdb.PeerHostInfo.hostname)
  return hostname_.GetNoArena();
}
inline void PeerHostInfo::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.PeerHostInfo.hostname)
}
#if LANG_CXX11
inline void PeerHostInfo::set_hostname(::std::string&& value) {
  
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.PeerHostInfo.hostname)
}
#endif
inline void PeerHostInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.PeerHostInfo.hostname)
}
inline void PeerHostInfo::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.PeerHostInfo.hostname)
}
inline ::std::string* PeerHostInfo::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.PeerHostInfo.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerHostInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:vaultdb.PeerHostInfo.hostname)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerHostInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.PeerHostInfo.hostname)
}

// int32 hostnum = 2;
inline void PeerHostInfo::clear_hostnum() {
  hostnum_ = 0;
}
inline ::google::protobuf::int32 PeerHostInfo::hostnum() const {
  // @@protoc_insertion_point(field_get:vaultdb.PeerHostInfo.hostnum)
  return hostnum_;
}
inline void PeerHostInfo::set_hostnum(::google::protobuf::int32 value) {
  
  hostnum_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.PeerHostInfo.hostnum)
}

// -------------------------------------------------------------------

// GetPeerHostsRequest

// repeated .vaultdb.PeerHostInfo hostnames = 1;
inline int GetPeerHostsRequest::hostnames_size() const {
  return hostnames_.size();
}
inline void GetPeerHostsRequest::clear_hostnames() {
  hostnames_.Clear();
}
inline ::vaultdb::PeerHostInfo* GetPeerHostsRequest::mutable_hostnames(int index) {
  // @@protoc_insertion_point(field_mutable:vaultdb.GetPeerHostsRequest.hostnames)
  return hostnames_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vaultdb::PeerHostInfo >*
GetPeerHostsRequest::mutable_hostnames() {
  // @@protoc_insertion_point(field_mutable_list:vaultdb.GetPeerHostsRequest.hostnames)
  return &hostnames_;
}
inline const ::vaultdb::PeerHostInfo& GetPeerHostsRequest::hostnames(int index) const {
  // @@protoc_insertion_point(field_get:vaultdb.GetPeerHostsRequest.hostnames)
  return hostnames_.Get(index);
}
inline ::vaultdb::PeerHostInfo* GetPeerHostsRequest::add_hostnames() {
  // @@protoc_insertion_point(field_add:vaultdb.GetPeerHostsRequest.hostnames)
  return hostnames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vaultdb::PeerHostInfo >&
GetPeerHostsRequest::hostnames() const {
  // @@protoc_insertion_point(field_list:vaultdb.GetPeerHostsRequest.hostnames)
  return hostnames_;
}

// -------------------------------------------------------------------

// GetPeerHostsResponse

// -------------------------------------------------------------------

// DBMSQueryRequest

// string dbname = 1;
inline void DBMSQueryRequest::clear_dbname() {
  dbname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DBMSQueryRequest::dbname() const {
  // @@protoc_insertion_point(field_get:vaultdb.DBMSQueryRequest.dbname)
  return dbname_.GetNoArena();
}
inline void DBMSQueryRequest::set_dbname(const ::std::string& value) {
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.DBMSQueryRequest.dbname)
}
#if LANG_CXX11
inline void DBMSQueryRequest::set_dbname(::std::string&& value) {
  
  dbname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.DBMSQueryRequest.dbname)
}
#endif
inline void DBMSQueryRequest::set_dbname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.DBMSQueryRequest.dbname)
}
inline void DBMSQueryRequest::set_dbname(const char* value, size_t size) {
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.DBMSQueryRequest.dbname)
}
inline ::std::string* DBMSQueryRequest::mutable_dbname() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.DBMSQueryRequest.dbname)
  return dbname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBMSQueryRequest::release_dbname() {
  // @@protoc_insertion_point(field_release:vaultdb.DBMSQueryRequest.dbname)
  
  return dbname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBMSQueryRequest::set_allocated_dbname(::std::string* dbname) {
  if (dbname != NULL) {
    
  } else {
    
  }
  dbname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dbname);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.DBMSQueryRequest.dbname)
}

// string query = 2;
inline void DBMSQueryRequest::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DBMSQueryRequest::query() const {
  // @@protoc_insertion_point(field_get:vaultdb.DBMSQueryRequest.query)
  return query_.GetNoArena();
}
inline void DBMSQueryRequest::set_query(const ::std::string& value) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.DBMSQueryRequest.query)
}
#if LANG_CXX11
inline void DBMSQueryRequest::set_query(::std::string&& value) {
  
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.DBMSQueryRequest.query)
}
#endif
inline void DBMSQueryRequest::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.DBMSQueryRequest.query)
}
inline void DBMSQueryRequest::set_query(const char* value, size_t size) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.DBMSQueryRequest.query)
}
inline ::std::string* DBMSQueryRequest::mutable_query() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.DBMSQueryRequest.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBMSQueryRequest::release_query() {
  // @@protoc_insertion_point(field_release:vaultdb.DBMSQueryRequest.query)
  
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBMSQueryRequest::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    
  } else {
    
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.DBMSQueryRequest.query)
}

// -------------------------------------------------------------------

// DBMSQueryResponse

// .vaultdb.TableID tableId = 1;
inline bool DBMSQueryResponse::has_tableid() const {
  return this != internal_default_instance() && tableid_ != NULL;
}
inline void DBMSQueryResponse::clear_tableid() {
  if (GetArenaNoVirtual() == NULL && tableid_ != NULL) {
    delete tableid_;
  }
  tableid_ = NULL;
}
inline const ::vaultdb::TableID& DBMSQueryResponse::_internal_tableid() const {
  return *tableid_;
}
inline const ::vaultdb::TableID& DBMSQueryResponse::tableid() const {
  const ::vaultdb::TableID* p = tableid_;
  // @@protoc_insertion_point(field_get:vaultdb.DBMSQueryResponse.tableId)
  return p != NULL ? *p : *reinterpret_cast<const ::vaultdb::TableID*>(
      &::vaultdb::_TableID_default_instance_);
}
inline ::vaultdb::TableID* DBMSQueryResponse::release_tableid() {
  // @@protoc_insertion_point(field_release:vaultdb.DBMSQueryResponse.tableId)
  
  ::vaultdb::TableID* temp = tableid_;
  tableid_ = NULL;
  return temp;
}
inline ::vaultdb::TableID* DBMSQueryResponse::mutable_tableid() {
  
  if (tableid_ == NULL) {
    auto* p = CreateMaybeMessage<::vaultdb::TableID>(GetArenaNoVirtual());
    tableid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vaultdb.DBMSQueryResponse.tableId)
  return tableid_;
}
inline void DBMSQueryResponse::set_allocated_tableid(::vaultdb::TableID* tableid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tableid_;
  }
  if (tableid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tableid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tableid, submessage_arena);
    }
    
  } else {
    
  }
  tableid_ = tableid;
  // @@protoc_insertion_point(field_set_allocated:vaultdb.DBMSQueryResponse.tableId)
}

// -------------------------------------------------------------------

// RegisterRequest

// string hostname = 1;
inline void RegisterRequest::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::hostname() const {
  // @@protoc_insertion_point(field_get:vaultdb.RegisterRequest.hostname)
  return hostname_.GetNoArena();
}
inline void RegisterRequest::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.RegisterRequest.hostname)
}
#if LANG_CXX11
inline void RegisterRequest::set_hostname(::std::string&& value) {
  
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.RegisterRequest.hostname)
}
#endif
inline void RegisterRequest::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.RegisterRequest.hostname)
}
inline void RegisterRequest::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.RegisterRequest.hostname)
}
inline ::std::string* RegisterRequest::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.RegisterRequest.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_hostname() {
  // @@protoc_insertion_point(field_release:vaultdb.RegisterRequest.hostname)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.RegisterRequest.hostname)
}

// -------------------------------------------------------------------

// RegisterResponse

// int32 host_num = 1;
inline void RegisterResponse::clear_host_num() {
  host_num_ = 0;
}
inline ::google::protobuf::int32 RegisterResponse::host_num() const {
  // @@protoc_insertion_point(field_get:vaultdb.RegisterResponse.host_num)
  return host_num_;
}
inline void RegisterResponse::set_host_num(::google::protobuf::int32 value) {
  
  host_num_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.RegisterResponse.host_num)
}

// -------------------------------------------------------------------

// NumHostsRequest

// -------------------------------------------------------------------

// NumHostResp

// int32 num_hosts = 1;
inline void NumHostResp::clear_num_hosts() {
  num_hosts_ = 0;
}
inline ::google::protobuf::int32 NumHostResp::num_hosts() const {
  // @@protoc_insertion_point(field_get:vaultdb.NumHostResp.num_hosts)
  return num_hosts_;
}
inline void NumHostResp::set_num_hosts(::google::protobuf::int32 value) {
  
  num_hosts_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.NumHostResp.num_hosts)
}

// -------------------------------------------------------------------

// DBQueryRequest

// string query_string = 1;
inline void DBQueryRequest::clear_query_string() {
  query_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DBQueryRequest::query_string() const {
  // @@protoc_insertion_point(field_get:vaultdb.DBQueryRequest.query_string)
  return query_string_.GetNoArena();
}
inline void DBQueryRequest::set_query_string(const ::std::string& value) {
  
  query_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.DBQueryRequest.query_string)
}
#if LANG_CXX11
inline void DBQueryRequest::set_query_string(::std::string&& value) {
  
  query_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.DBQueryRequest.query_string)
}
#endif
inline void DBQueryRequest::set_query_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  query_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.DBQueryRequest.query_string)
}
inline void DBQueryRequest::set_query_string(const char* value, size_t size) {
  
  query_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.DBQueryRequest.query_string)
}
inline ::std::string* DBQueryRequest::mutable_query_string() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.DBQueryRequest.query_string)
  return query_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBQueryRequest::release_query_string() {
  // @@protoc_insertion_point(field_release:vaultdb.DBQueryRequest.query_string)
  
  return query_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBQueryRequest::set_allocated_query_string(::std::string* query_string) {
  if (query_string != NULL) {
    
  } else {
    
  }
  query_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query_string);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.DBQueryRequest.query_string)
}

// string dbname = 2;
inline void DBQueryRequest::clear_dbname() {
  dbname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DBQueryRequest::dbname() const {
  // @@protoc_insertion_point(field_get:vaultdb.DBQueryRequest.dbname)
  return dbname_.GetNoArena();
}
inline void DBQueryRequest::set_dbname(const ::std::string& value) {
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.DBQueryRequest.dbname)
}
#if LANG_CXX11
inline void DBQueryRequest::set_dbname(::std::string&& value) {
  
  dbname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.DBQueryRequest.dbname)
}
#endif
inline void DBQueryRequest::set_dbname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.DBQueryRequest.dbname)
}
inline void DBQueryRequest::set_dbname(const char* value, size_t size) {
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.DBQueryRequest.dbname)
}
inline ::std::string* DBQueryRequest::mutable_dbname() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.DBQueryRequest.dbname)
  return dbname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBQueryRequest::release_dbname() {
  // @@protoc_insertion_point(field_release:vaultdb.DBQueryRequest.dbname)
  
  return dbname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBQueryRequest::set_allocated_dbname(::std::string* dbname) {
  if (dbname != NULL) {
    
  } else {
    
  }
  dbname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dbname);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.DBQueryRequest.dbname)
}

// -------------------------------------------------------------------

// DBQueryResponse

// string db_response = 1;
inline void DBQueryResponse::clear_db_response() {
  db_response_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DBQueryResponse::db_response() const {
  // @@protoc_insertion_point(field_get:vaultdb.DBQueryResponse.db_response)
  return db_response_.GetNoArena();
}
inline void DBQueryResponse::set_db_response(const ::std::string& value) {
  
  db_response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.DBQueryResponse.db_response)
}
#if LANG_CXX11
inline void DBQueryResponse::set_db_response(::std::string&& value) {
  
  db_response_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.DBQueryResponse.db_response)
}
#endif
inline void DBQueryResponse::set_db_response(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.DBQueryResponse.db_response)
}
inline void DBQueryResponse::set_db_response(const char* value, size_t size) {
  
  db_response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.DBQueryResponse.db_response)
}
inline ::std::string* DBQueryResponse::mutable_db_response() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.DBQueryResponse.db_response)
  return db_response_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBQueryResponse::release_db_response() {
  // @@protoc_insertion_point(field_release:vaultdb.DBQueryResponse.db_response)
  
  return db_response_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBQueryResponse::set_allocated_db_response(::std::string* db_response) {
  if (db_response != NULL) {
    
  } else {
    
  }
  db_response_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_response);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.DBQueryResponse.db_response)
}

// -------------------------------------------------------------------

// TableRequest

// -------------------------------------------------------------------

// TableResponse

// .vaultdb.Table t = 1;
inline bool TableResponse::has_t() const {
  return this != internal_default_instance() && t_ != NULL;
}
inline void TableResponse::clear_t() {
  if (GetArenaNoVirtual() == NULL && t_ != NULL) {
    delete t_;
  }
  t_ = NULL;
}
inline const ::vaultdb::Table& TableResponse::_internal_t() const {
  return *t_;
}
inline const ::vaultdb::Table& TableResponse::t() const {
  const ::vaultdb::Table* p = t_;
  // @@protoc_insertion_point(field_get:vaultdb.TableResponse.t)
  return p != NULL ? *p : *reinterpret_cast<const ::vaultdb::Table*>(
      &::vaultdb::_Table_default_instance_);
}
inline ::vaultdb::Table* TableResponse::release_t() {
  // @@protoc_insertion_point(field_release:vaultdb.TableResponse.t)
  
  ::vaultdb::Table* temp = t_;
  t_ = NULL;
  return temp;
}
inline ::vaultdb::Table* TableResponse::mutable_t() {
  
  if (t_ == NULL) {
    auto* p = CreateMaybeMessage<::vaultdb::Table>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vaultdb.TableResponse.t)
  return t_;
}
inline void TableResponse::set_allocated_t(::vaultdb::Table* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableResponse.t)
}

// -------------------------------------------------------------------

// schema

// repeated .vaultdb.Table q = 2;
inline int schema::q_size() const {
  return q_.size();
}
inline void schema::clear_q() {
  q_.Clear();
}
inline ::vaultdb::Table* schema::mutable_q(int index) {
  // @@protoc_insertion_point(field_mutable:vaultdb.schema.q)
  return q_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vaultdb::Table >*
schema::mutable_q() {
  // @@protoc_insertion_point(field_mutable_list:vaultdb.schema.q)
  return &q_;
}
inline const ::vaultdb::Table& schema::q(int index) const {
  // @@protoc_insertion_point(field_get:vaultdb.schema.q)
  return q_.Get(index);
}
inline ::vaultdb::Table* schema::add_q() {
  // @@protoc_insertion_point(field_add:vaultdb.schema.q)
  return q_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vaultdb::Table >&
schema::q() const {
  // @@protoc_insertion_point(field_list:vaultdb.schema.q)
  return q_;
}

// -------------------------------------------------------------------

// TableStream

// .vaultdb.Table t = 1;
inline bool TableStream::has_t() const {
  return this != internal_default_instance() && t_ != NULL;
}
inline void TableStream::clear_t() {
  if (GetArenaNoVirtual() == NULL && t_ != NULL) {
    delete t_;
  }
  t_ = NULL;
}
inline const ::vaultdb::Table& TableStream::_internal_t() const {
  return *t_;
}
inline const ::vaultdb::Table& TableStream::t() const {
  const ::vaultdb::Table* p = t_;
  // @@protoc_insertion_point(field_get:vaultdb.TableStream.t)
  return p != NULL ? *p : *reinterpret_cast<const ::vaultdb::Table*>(
      &::vaultdb::_Table_default_instance_);
}
inline ::vaultdb::Table* TableStream::release_t() {
  // @@protoc_insertion_point(field_release:vaultdb.TableStream.t)
  
  ::vaultdb::Table* temp = t_;
  t_ = NULL;
  return temp;
}
inline ::vaultdb::Table* TableStream::mutable_t() {
  
  if (t_ == NULL) {
    auto* p = CreateMaybeMessage<::vaultdb::Table>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vaultdb.TableStream.t)
  return t_;
}
inline void TableStream::set_allocated_t(::vaultdb::Table* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableStream.t)
}

// int32 page_no = 3;
inline void TableStream::clear_page_no() {
  page_no_ = 0;
}
inline ::google::protobuf::int32 TableStream::page_no() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableStream.page_no)
  return page_no_;
}
inline void TableStream::set_page_no(::google::protobuf::int32 value) {
  
  page_no_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TableStream.page_no)
}

// bytes page = 4;
inline void TableStream::clear_page() {
  page_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableStream::page() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableStream.page)
  return page_.GetNoArena();
}
inline void TableStream::set_page(const ::std::string& value) {
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.TableStream.page)
}
#if LANG_CXX11
inline void TableStream::set_page(::std::string&& value) {
  
  page_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.TableStream.page)
}
#endif
inline void TableStream::set_page(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.TableStream.page)
}
inline void TableStream::set_page(const void* value, size_t size) {
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.TableStream.page)
}
inline ::std::string* TableStream::mutable_page() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.TableStream.page)
  return page_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableStream::release_page() {
  // @@protoc_insertion_point(field_release:vaultdb.TableStream.page)
  
  return page_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableStream::set_allocated_page(::std::string* page) {
  if (page != NULL) {
    
  } else {
    
  }
  page_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableStream.page)
}

// -------------------------------------------------------------------

// Table

// int32 num_tuple_pages = 1;
inline void Table::clear_num_tuple_pages() {
  num_tuple_pages_ = 0;
}
inline ::google::protobuf::int32 Table::num_tuple_pages() const {
  // @@protoc_insertion_point(field_get:vaultdb.Table.num_tuple_pages)
  return num_tuple_pages_;
}
inline void Table::set_num_tuple_pages(::google::protobuf::int32 value) {
  
  num_tuple_pages_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.Table.num_tuple_pages)
}

// int32 num_tuples = 2;
inline void Table::clear_num_tuples() {
  num_tuples_ = 0;
}
inline ::google::protobuf::int32 Table::num_tuples() const {
  // @@protoc_insertion_point(field_get:vaultdb.Table.num_tuples)
  return num_tuples_;
}
inline void Table::set_num_tuples(::google::protobuf::int32 value) {
  
  num_tuples_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.Table.num_tuples)
}

// int32 size_of_tuple = 3;
inline void Table::clear_size_of_tuple() {
  size_of_tuple_ = 0;
}
inline ::google::protobuf::int32 Table::size_of_tuple() const {
  // @@protoc_insertion_point(field_get:vaultdb.Table.size_of_tuple)
  return size_of_tuple_;
}
inline void Table::set_size_of_tuple(::google::protobuf::int32 value) {
  
  size_of_tuple_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.Table.size_of_tuple)
}

// bytes schema = 4;
inline void Table::clear_schema() {
  schema_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Table::schema() const {
  // @@protoc_insertion_point(field_get:vaultdb.Table.schema)
  return schema_.GetNoArena();
}
inline void Table::set_schema(const ::std::string& value) {
  
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.Table.schema)
}
#if LANG_CXX11
inline void Table::set_schema(::std::string&& value) {
  
  schema_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.Table.schema)
}
#endif
inline void Table::set_schema(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.Table.schema)
}
inline void Table::set_schema(const void* value, size_t size) {
  
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.Table.schema)
}
inline ::std::string* Table::mutable_schema() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.Table.schema)
  return schema_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Table::release_schema() {
  // @@protoc_insertion_point(field_release:vaultdb.Table.schema)
  
  return schema_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Table::set_allocated_schema(::std::string* schema) {
  if (schema != NULL) {
    
  } else {
    
  }
  schema_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.Table.schema)
}

// -------------------------------------------------------------------

// TuplePage

// int32 page_no = 1;
inline void TuplePage::clear_page_no() {
  page_no_ = 0;
}
inline ::google::protobuf::int32 TuplePage::page_no() const {
  // @@protoc_insertion_point(field_get:vaultdb.TuplePage.page_no)
  return page_no_;
}
inline void TuplePage::set_page_no(::google::protobuf::int32 value) {
  
  page_no_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TuplePage.page_no)
}

// bytes page = 2;
inline void TuplePage::clear_page() {
  page_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TuplePage::page() const {
  // @@protoc_insertion_point(field_get:vaultdb.TuplePage.page)
  return page_.GetNoArena();
}
inline void TuplePage::set_page(const ::std::string& value) {
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.TuplePage.page)
}
#if LANG_CXX11
inline void TuplePage::set_page(::std::string&& value) {
  
  page_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.TuplePage.page)
}
#endif
inline void TuplePage::set_page(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.TuplePage.page)
}
inline void TuplePage::set_page(const void* value, size_t size) {
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.TuplePage.page)
}
inline ::std::string* TuplePage::mutable_page() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.TuplePage.page)
  return page_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TuplePage::release_page() {
  // @@protoc_insertion_point(field_release:vaultdb.TuplePage.page)
  
  return page_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TuplePage::set_allocated_page(::std::string* page) {
  if (page != NULL) {
    
  } else {
    
  }
  page_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TuplePage.page)
}

// -------------------------------------------------------------------

// FieldDesc

// string field_name = 1;
inline void FieldDesc::clear_field_name() {
  field_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FieldDesc::field_name() const {
  // @@protoc_insertion_point(field_get:vaultdb.FieldDesc.field_name)
  return field_name_.GetNoArena();
}
inline void FieldDesc::set_field_name(const ::std::string& value) {
  
  field_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.FieldDesc.field_name)
}
#if LANG_CXX11
inline void FieldDesc::set_field_name(::std::string&& value) {
  
  field_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.FieldDesc.field_name)
}
#endif
inline void FieldDesc::set_field_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  field_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.FieldDesc.field_name)
}
inline void FieldDesc::set_field_name(const char* value, size_t size) {
  
  field_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.FieldDesc.field_name)
}
inline ::std::string* FieldDesc::mutable_field_name() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.FieldDesc.field_name)
  return field_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDesc::release_field_name() {
  // @@protoc_insertion_point(field_release:vaultdb.FieldDesc.field_name)
  
  return field_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDesc::set_allocated_field_name(::std::string* field_name) {
  if (field_name != NULL) {
    
  } else {
    
  }
  field_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_name);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.FieldDesc.field_name)
}

// int32 col_no = 2;
inline void FieldDesc::clear_col_no() {
  col_no_ = 0;
}
inline ::google::protobuf::int32 FieldDesc::col_no() const {
  // @@protoc_insertion_point(field_get:vaultdb.FieldDesc.col_no)
  return col_no_;
}
inline void FieldDesc::set_col_no(::google::protobuf::int32 value) {
  
  col_no_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.FieldDesc.col_no)
}

// .vaultdb.FieldDesc.FieldType field_type = 3;
inline void FieldDesc::clear_field_type() {
  field_type_ = 0;
}
inline ::vaultdb::FieldDesc_FieldType FieldDesc::field_type() const {
  // @@protoc_insertion_point(field_get:vaultdb.FieldDesc.field_type)
  return static_cast< ::vaultdb::FieldDesc_FieldType >(field_type_);
}
inline void FieldDesc::set_field_type(::vaultdb::FieldDesc_FieldType value) {
  
  field_type_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.FieldDesc.field_type)
}

// -------------------------------------------------------------------

// Schema

// int32 num_fields = 1;
inline void Schema::clear_num_fields() {
  num_fields_ = 0;
}
inline ::google::protobuf::int32 Schema::num_fields() const {
  // @@protoc_insertion_point(field_get:vaultdb.Schema.num_fields)
  return num_fields_;
}
inline void Schema::set_num_fields(::google::protobuf::int32 value) {
  
  num_fields_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.Schema.num_fields)
}

// repeated .vaultdb.FieldDesc field = 2;
inline int Schema::field_size() const {
  return field_.size();
}
inline void Schema::clear_field() {
  field_.Clear();
}
inline ::vaultdb::FieldDesc* Schema::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:vaultdb.Schema.field)
  return field_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vaultdb::FieldDesc >*
Schema::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:vaultdb.Schema.field)
  return &field_;
}
inline const ::vaultdb::FieldDesc& Schema::field(int index) const {
  // @@protoc_insertion_point(field_get:vaultdb.Schema.field)
  return field_.Get(index);
}
inline ::vaultdb::FieldDesc* Schema::add_field() {
  // @@protoc_insertion_point(field_add:vaultdb.Schema.field)
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vaultdb::FieldDesc >&
Schema::field() const {
  // @@protoc_insertion_point(field_list:vaultdb.Schema.field)
  return field_;
}

// -------------------------------------------------------------------

// TableQueryRequest

// string dbname = 1;
inline void TableQueryRequest::clear_dbname() {
  dbname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableQueryRequest::dbname() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryRequest.dbname)
  return dbname_.GetNoArena();
}
inline void TableQueryRequest::set_dbname(const ::std::string& value) {
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.TableQueryRequest.dbname)
}
#if LANG_CXX11
inline void TableQueryRequest::set_dbname(::std::string&& value) {
  
  dbname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.TableQueryRequest.dbname)
}
#endif
inline void TableQueryRequest::set_dbname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.TableQueryRequest.dbname)
}
inline void TableQueryRequest::set_dbname(const char* value, size_t size) {
  
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.TableQueryRequest.dbname)
}
inline ::std::string* TableQueryRequest::mutable_dbname() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.TableQueryRequest.dbname)
  return dbname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableQueryRequest::release_dbname() {
  // @@protoc_insertion_point(field_release:vaultdb.TableQueryRequest.dbname)
  
  return dbname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableQueryRequest::set_allocated_dbname(::std::string* dbname) {
  if (dbname != NULL) {
    
  } else {
    
  }
  dbname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dbname);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableQueryRequest.dbname)
}

// string query = 2;
inline void TableQueryRequest::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableQueryRequest::query() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryRequest.query)
  return query_.GetNoArena();
}
inline void TableQueryRequest::set_query(const ::std::string& value) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.TableQueryRequest.query)
}
#if LANG_CXX11
inline void TableQueryRequest::set_query(::std::string&& value) {
  
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.TableQueryRequest.query)
}
#endif
inline void TableQueryRequest::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.TableQueryRequest.query)
}
inline void TableQueryRequest::set_query(const char* value, size_t size) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.TableQueryRequest.query)
}
inline ::std::string* TableQueryRequest::mutable_query() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.TableQueryRequest.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableQueryRequest::release_query() {
  // @@protoc_insertion_point(field_release:vaultdb.TableQueryRequest.query)
  
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableQueryRequest::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    
  } else {
    
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableQueryRequest.query)
}

// -------------------------------------------------------------------

// TableQueryResponse

// bool is_header = 2;
inline void TableQueryResponse::clear_is_header() {
  is_header_ = false;
}
inline bool TableQueryResponse::is_header() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryResponse.is_header)
  return is_header_;
}
inline void TableQueryResponse::set_is_header(bool value) {
  
  is_header_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TableQueryResponse.is_header)
}

// .vaultdb.Schema schema = 3;
inline bool TableQueryResponse::has_schema() const {
  return this != internal_default_instance() && schema_ != NULL;
}
inline void TableQueryResponse::clear_schema() {
  if (GetArenaNoVirtual() == NULL && schema_ != NULL) {
    delete schema_;
  }
  schema_ = NULL;
}
inline const ::vaultdb::Schema& TableQueryResponse::_internal_schema() const {
  return *schema_;
}
inline const ::vaultdb::Schema& TableQueryResponse::schema() const {
  const ::vaultdb::Schema* p = schema_;
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryResponse.schema)
  return p != NULL ? *p : *reinterpret_cast<const ::vaultdb::Schema*>(
      &::vaultdb::_Schema_default_instance_);
}
inline ::vaultdb::Schema* TableQueryResponse::release_schema() {
  // @@protoc_insertion_point(field_release:vaultdb.TableQueryResponse.schema)
  
  ::vaultdb::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline ::vaultdb::Schema* TableQueryResponse::mutable_schema() {
  
  if (schema_ == NULL) {
    auto* p = CreateMaybeMessage<::vaultdb::Schema>(GetArenaNoVirtual());
    schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vaultdb.TableQueryResponse.schema)
  return schema_;
}
inline void TableQueryResponse::set_allocated_schema(::vaultdb::Schema* schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete schema_;
  }
  if (schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableQueryResponse.schema)
}

// int32 num_tuples = 4;
inline void TableQueryResponse::clear_num_tuples() {
  num_tuples_ = 0;
}
inline ::google::protobuf::int32 TableQueryResponse::num_tuples() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryResponse.num_tuples)
  return num_tuples_;
}
inline void TableQueryResponse::set_num_tuples(::google::protobuf::int32 value) {
  
  num_tuples_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TableQueryResponse.num_tuples)
}

// int32 size_of_tuple = 5;
inline void TableQueryResponse::clear_size_of_tuple() {
  size_of_tuple_ = 0;
}
inline ::google::protobuf::int32 TableQueryResponse::size_of_tuple() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryResponse.size_of_tuple)
  return size_of_tuple_;
}
inline void TableQueryResponse::set_size_of_tuple(::google::protobuf::int32 value) {
  
  size_of_tuple_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TableQueryResponse.size_of_tuple)
}

// int32 num_tuple_pages = 6;
inline void TableQueryResponse::clear_num_tuple_pages() {
  num_tuple_pages_ = 0;
}
inline ::google::protobuf::int32 TableQueryResponse::num_tuple_pages() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryResponse.num_tuple_pages)
  return num_tuple_pages_;
}
inline void TableQueryResponse::set_num_tuple_pages(::google::protobuf::int32 value) {
  
  num_tuple_pages_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TableQueryResponse.num_tuple_pages)
}

// int32 page_no = 7;
inline void TableQueryResponse::clear_page_no() {
  page_no_ = 0;
}
inline ::google::protobuf::int32 TableQueryResponse::page_no() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryResponse.page_no)
  return page_no_;
}
inline void TableQueryResponse::set_page_no(::google::protobuf::int32 value) {
  
  page_no_ = value;
  // @@protoc_insertion_point(field_set:vaultdb.TableQueryResponse.page_no)
}

// bytes page = 8;
inline void TableQueryResponse::clear_page() {
  page_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableQueryResponse::page() const {
  // @@protoc_insertion_point(field_get:vaultdb.TableQueryResponse.page)
  return page_.GetNoArena();
}
inline void TableQueryResponse::set_page(const ::std::string& value) {
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vaultdb.TableQueryResponse.page)
}
#if LANG_CXX11
inline void TableQueryResponse::set_page(::std::string&& value) {
  
  page_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vaultdb.TableQueryResponse.page)
}
#endif
inline void TableQueryResponse::set_page(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vaultdb.TableQueryResponse.page)
}
inline void TableQueryResponse::set_page(const void* value, size_t size) {
  
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vaultdb.TableQueryResponse.page)
}
inline ::std::string* TableQueryResponse::mutable_page() {
  
  // @@protoc_insertion_point(field_mutable:vaultdb.TableQueryResponse.page)
  return page_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableQueryResponse::release_page() {
  // @@protoc_insertion_point(field_release:vaultdb.TableQueryResponse.page)
  
  return page_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableQueryResponse::set_allocated_page(::std::string* page) {
  if (page != NULL) {
    
  } else {
    
  }
  page_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page);
  // @@protoc_insertion_point(field_set_allocated:vaultdb.TableQueryResponse.page)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vaultdb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vaultdb::FieldDesc_FieldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vaultdb::FieldDesc_FieldType>() {
  return ::vaultdb::FieldDesc_FieldType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_vaultdb_2eproto
