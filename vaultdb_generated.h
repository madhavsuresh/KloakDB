// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VAULTDB_H_
#define FLATBUFFERS_GENERATED_VAULTDB_H_

#include "flatbuffers/flatbuffers.h"

struct ProjectList;

struct GroupByDef;

struct EqExpr;

struct TimeStampField;

struct VarCharField;

struct IntField;

struct FieldDesc;

struct Schema;

struct Field;

struct Tuple;

struct Expr;

struct Table;

inline const flatbuffers::TypeTable *ProjectListTypeTable();

inline const flatbuffers::TypeTable *GroupByDefTypeTable();

inline const flatbuffers::TypeTable *EqExprTypeTable();

inline const flatbuffers::TypeTable *TimeStampFieldTypeTable();

inline const flatbuffers::TypeTable *VarCharFieldTypeTable();

inline const flatbuffers::TypeTable *IntFieldTypeTable();

inline const flatbuffers::TypeTable *FieldDescTypeTable();

inline const flatbuffers::TypeTable *SchemaTypeTable();

inline const flatbuffers::TypeTable *FieldTypeTable();

inline const flatbuffers::TypeTable *TupleTypeTable();

inline const flatbuffers::TypeTable *ExprTypeTable();

inline const flatbuffers::TypeTable *TableTypeTable();

enum FieldType {
  FieldType_VARCHAR = 0,
  FieldType_INT = 1,
  FieldType_TIMESTAMP = 2,
  FieldType_UNSUPPORTED = 3,
  FieldType_MIN = FieldType_VARCHAR,
  FieldType_MAX = FieldType_UNSUPPORTED
};

inline const FieldType (&EnumValuesFieldType())[4] {
  static const FieldType values[] = {
    FieldType_VARCHAR,
    FieldType_INT,
    FieldType_TIMESTAMP,
    FieldType_UNSUPPORTED
  };
  return values;
}

inline const char * const *EnumNamesFieldType() {
  static const char * const names[] = {
    "VARCHAR",
    "INT",
    "TIMESTAMP",
    "UNSUPPORTED",
    nullptr
  };
  return names;
}

inline const char *EnumNameFieldType(FieldType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFieldType()[index];
}

enum GroupByType {
  GroupByType_MINX = 0,
  GroupByType_COUNT = 1,
  GroupByType_UNSUPPPORTED = 2,
  GroupByType_MIN = GroupByType_MINX,
  GroupByType_MAX = GroupByType_UNSUPPPORTED
};

inline const GroupByType (&EnumValuesGroupByType())[3] {
  static const GroupByType values[] = {
    GroupByType_MINX,
    GroupByType_COUNT,
    GroupByType_UNSUPPPORTED
  };
  return values;
}

inline const char * const *EnumNamesGroupByType() {
  static const char * const names[] = {
    "MINX",
    "COUNT",
    "UNSUPPPORTED",
    nullptr
  };
  return names;
}

inline const char *EnumNameGroupByType(GroupByType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGroupByType()[index];
}

enum ExprUnion {
  ExprUnion_NONE = 0,
  ExprUnion_EqExpr = 1,
  ExprUnion_MIN = ExprUnion_NONE,
  ExprUnion_MAX = ExprUnion_EqExpr
};

inline const ExprUnion (&EnumValuesExprUnion())[2] {
  static const ExprUnion values[] = {
    ExprUnion_NONE,
    ExprUnion_EqExpr
  };
  return values;
}

inline const char * const *EnumNamesExprUnion() {
  static const char * const names[] = {
    "NONE",
    "EqExpr",
    nullptr
  };
  return names;
}

inline const char *EnumNameExprUnion(ExprUnion e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesExprUnion()[index];
}

template<typename T> struct ExprUnionTraits {
  static const ExprUnion enum_value = ExprUnion_NONE;
};

template<> struct ExprUnionTraits<EqExpr> {
  static const ExprUnion enum_value = ExprUnion_EqExpr;
};

bool VerifyExprUnion(flatbuffers::Verifier &verifier, const void *obj, ExprUnion type);
bool VerifyExprUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum FieldVal {
  FieldVal_NONE = 0,
  FieldVal_TimeStampField = 1,
  FieldVal_IntField = 2,
  FieldVal_VarCharField = 3,
  FieldVal_MIN = FieldVal_NONE,
  FieldVal_MAX = FieldVal_VarCharField
};

inline const FieldVal (&EnumValuesFieldVal())[4] {
  static const FieldVal values[] = {
    FieldVal_NONE,
    FieldVal_TimeStampField,
    FieldVal_IntField,
    FieldVal_VarCharField
  };
  return values;
}

inline const char * const *EnumNamesFieldVal() {
  static const char * const names[] = {
    "NONE",
    "TimeStampField",
    "IntField",
    "VarCharField",
    nullptr
  };
  return names;
}

inline const char *EnumNameFieldVal(FieldVal e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFieldVal()[index];
}

template<typename T> struct FieldValTraits {
  static const FieldVal enum_value = FieldVal_NONE;
};

template<> struct FieldValTraits<TimeStampField> {
  static const FieldVal enum_value = FieldVal_TimeStampField;
};

template<> struct FieldValTraits<IntField> {
  static const FieldVal enum_value = FieldVal_IntField;
};

template<> struct FieldValTraits<VarCharField> {
  static const FieldVal enum_value = FieldVal_VarCharField;
};

bool VerifyFieldVal(flatbuffers::Verifier &verifier, const void *obj, FieldVal type);
bool VerifyFieldValVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ProjectList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProjectListTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ProjectList";
  }
  enum {
    VT_COLS = 4
  };
  const flatbuffers::Vector<int32_t> *cols() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_COLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLS) &&
           verifier.Verify(cols()) &&
           verifier.EndTable();
  }
};

struct ProjectListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cols(flatbuffers::Offset<flatbuffers::Vector<int32_t>> cols) {
    fbb_.AddOffset(ProjectList::VT_COLS, cols);
  }
  explicit ProjectListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectListBuilder &operator=(const ProjectListBuilder &);
  flatbuffers::Offset<ProjectList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectList>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectList> CreateProjectList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> cols = 0) {
  ProjectListBuilder builder_(_fbb);
  builder_.add_cols(cols);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectList> CreateProjectListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *cols = nullptr) {
  return CreateProjectList(
      _fbb,
      cols ? _fbb.CreateVector<int32_t>(*cols) : 0);
}

struct GroupByDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GroupByDefTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "GroupByDef";
  }
  enum {
    VT_COLNO = 4,
    VT_OPTYPE = 6
  };
  int32_t colno() const {
    return GetField<int32_t>(VT_COLNO, 0);
  }
  GroupByType optype() const {
    return static_cast<GroupByType>(GetField<int8_t>(VT_OPTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COLNO) &&
           VerifyField<int8_t>(verifier, VT_OPTYPE) &&
           verifier.EndTable();
  }
};

struct GroupByDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colno(int32_t colno) {
    fbb_.AddElement<int32_t>(GroupByDef::VT_COLNO, colno, 0);
  }
  void add_optype(GroupByType optype) {
    fbb_.AddElement<int8_t>(GroupByDef::VT_OPTYPE, static_cast<int8_t>(optype), 0);
  }
  explicit GroupByDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupByDefBuilder &operator=(const GroupByDefBuilder &);
  flatbuffers::Offset<GroupByDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupByDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupByDef> CreateGroupByDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t colno = 0,
    GroupByType optype = GroupByType_MINX) {
  GroupByDefBuilder builder_(_fbb);
  builder_.add_colno(colno);
  builder_.add_optype(optype);
  return builder_.Finish();
}

struct EqExpr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EqExprTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "EqExpr";
  }
  enum {
    VT_COLNO = 4,
    VT_VAL_TYPE = 6,
    VT_VAL = 8
  };
  int32_t colno() const {
    return GetField<int32_t>(VT_COLNO, 0);
  }
  FieldVal val_type() const {
    return static_cast<FieldVal>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const TimeStampField *val_as_TimeStampField() const {
    return val_type() == FieldVal_TimeStampField ? static_cast<const TimeStampField *>(val()) : nullptr;
  }
  const IntField *val_as_IntField() const {
    return val_type() == FieldVal_IntField ? static_cast<const IntField *>(val()) : nullptr;
  }
  const VarCharField *val_as_VarCharField() const {
    return val_type() == FieldVal_VarCharField ? static_cast<const VarCharField *>(val()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COLNO) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyFieldVal(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const TimeStampField *EqExpr::val_as<TimeStampField>() const {
  return val_as_TimeStampField();
}

template<> inline const IntField *EqExpr::val_as<IntField>() const {
  return val_as_IntField();
}

template<> inline const VarCharField *EqExpr::val_as<VarCharField>() const {
  return val_as_VarCharField();
}

struct EqExprBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colno(int32_t colno) {
    fbb_.AddElement<int32_t>(EqExpr::VT_COLNO, colno, 0);
  }
  void add_val_type(FieldVal val_type) {
    fbb_.AddElement<uint8_t>(EqExpr::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(flatbuffers::Offset<void> val) {
    fbb_.AddOffset(EqExpr::VT_VAL, val);
  }
  explicit EqExprBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqExprBuilder &operator=(const EqExprBuilder &);
  flatbuffers::Offset<EqExpr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqExpr>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqExpr> CreateEqExpr(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t colno = 0,
    FieldVal val_type = FieldVal_NONE,
    flatbuffers::Offset<void> val = 0) {
  EqExprBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_colno(colno);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct TimeStampField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TimeStampFieldTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "TimeStampField";
  }
  enum {
    VT_VAL = 4
  };
  float val() const {
    return GetField<float>(VT_VAL, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VAL) &&
           verifier.EndTable();
  }
};

struct TimeStampFieldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_val(float val) {
    fbb_.AddElement<float>(TimeStampField::VT_VAL, val, 0.0f);
  }
  explicit TimeStampFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeStampFieldBuilder &operator=(const TimeStampFieldBuilder &);
  flatbuffers::Offset<TimeStampField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeStampField>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeStampField> CreateTimeStampField(
    flatbuffers::FlatBufferBuilder &_fbb,
    float val = 0.0f) {
  TimeStampFieldBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct VarCharField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VarCharFieldTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "VarCharField";
  }
  enum {
    VT_VAL = 4
  };
  const flatbuffers::String *val() const {
    return GetPointer<const flatbuffers::String *>(VT_VAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.Verify(val()) &&
           verifier.EndTable();
  }
};

struct VarCharFieldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_val(flatbuffers::Offset<flatbuffers::String> val) {
    fbb_.AddOffset(VarCharField::VT_VAL, val);
  }
  explicit VarCharFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarCharFieldBuilder &operator=(const VarCharFieldBuilder &);
  flatbuffers::Offset<VarCharField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarCharField>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarCharField> CreateVarCharField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> val = 0) {
  VarCharFieldBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

inline flatbuffers::Offset<VarCharField> CreateVarCharFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *val = nullptr) {
  return CreateVarCharField(
      _fbb,
      val ? _fbb.CreateString(val) : 0);
}

struct IntField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntFieldTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "IntField";
  }
  enum {
    VT_VAL = 4
  };
  int32_t val() const {
    return GetField<int32_t>(VT_VAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAL) &&
           verifier.EndTable();
  }
};

struct IntFieldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_val(int32_t val) {
    fbb_.AddElement<int32_t>(IntField::VT_VAL, val, 0);
  }
  explicit IntFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntFieldBuilder &operator=(const IntFieldBuilder &);
  flatbuffers::Offset<IntField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntField>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntField> CreateIntField(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t val = 0) {
  IntFieldBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct FieldDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FieldDescTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "FieldDesc";
  }
  enum {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_COL = 8
  };
  FieldType type() const {
    return static_cast<FieldType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t col() const {
    return GetField<int32_t>(VT_COL, -1);
  }
  bool KeyCompareLessThan(const FieldDesc *o) const {
    return col() < o->col();
  }
  int KeyCompareWithValue(int32_t val) const {
    const auto key = col();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_COL) &&
           verifier.EndTable();
  }
};

struct FieldDescBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(FieldType type) {
    fbb_.AddElement<int8_t>(FieldDesc::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FieldDesc::VT_NAME, name);
  }
  void add_col(int32_t col) {
    fbb_.AddElement<int32_t>(FieldDesc::VT_COL, col, -1);
  }
  explicit FieldDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldDescBuilder &operator=(const FieldDescBuilder &);
  flatbuffers::Offset<FieldDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldDesc> CreateFieldDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    FieldType type = FieldType_VARCHAR,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t col = -1) {
  FieldDescBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FieldDesc> CreateFieldDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FieldType type = FieldType_VARCHAR,
    const char *name = nullptr,
    int32_t col = -1) {
  return CreateFieldDesc(
      _fbb,
      type,
      name ? _fbb.CreateString(name) : 0,
      col);
}

struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SchemaTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Schema";
  }
  enum {
    VT_FIELDDESCS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FieldDesc>> *fielddescs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FieldDesc>> *>(VT_FIELDDESCS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDDESCS) &&
           verifier.Verify(fielddescs()) &&
           verifier.VerifyVectorOfTables(fielddescs()) &&
           verifier.EndTable();
  }
};

struct SchemaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fielddescs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FieldDesc>>> fielddescs) {
    fbb_.AddOffset(Schema::VT_FIELDDESCS, fielddescs);
  }
  explicit SchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SchemaBuilder &operator=(const SchemaBuilder &);
  flatbuffers::Offset<Schema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Schema>(end);
    return o;
  }
};

inline flatbuffers::Offset<Schema> CreateSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FieldDesc>>> fielddescs = 0) {
  SchemaBuilder builder_(_fbb);
  builder_.add_fielddescs(fielddescs);
  return builder_.Finish();
}

inline flatbuffers::Offset<Schema> CreateSchemaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FieldDesc>> *fielddescs = nullptr) {
  return CreateSchema(
      _fbb,
      fielddescs ? _fbb.CreateVector<flatbuffers::Offset<FieldDesc>>(*fielddescs) : 0);
}

struct Field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FieldTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Field";
  }
  enum {
    VT_FIELDNUM = 4,
    VT_VAL_TYPE = 6,
    VT_VAL = 8,
    VT_GENVAL_TYPE = 10,
    VT_GENVAL = 12
  };
  int32_t fieldnum() const {
    return GetField<int32_t>(VT_FIELDNUM, -1);
  }
  bool KeyCompareLessThan(const Field *o) const {
    return fieldnum() < o->fieldnum();
  }
  int KeyCompareWithValue(int32_t val) const {
    const auto key = fieldnum();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  FieldVal val_type() const {
    return static_cast<FieldVal>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const TimeStampField *val_as_TimeStampField() const {
    return val_type() == FieldVal_TimeStampField ? static_cast<const TimeStampField *>(val()) : nullptr;
  }
  const IntField *val_as_IntField() const {
    return val_type() == FieldVal_IntField ? static_cast<const IntField *>(val()) : nullptr;
  }
  const VarCharField *val_as_VarCharField() const {
    return val_type() == FieldVal_VarCharField ? static_cast<const VarCharField *>(val()) : nullptr;
  }
  FieldVal genval_type() const {
    return static_cast<FieldVal>(GetField<uint8_t>(VT_GENVAL_TYPE, 0));
  }
  const void *genval() const {
    return GetPointer<const void *>(VT_GENVAL);
  }
  template<typename T> const T *genval_as() const;
  const TimeStampField *genval_as_TimeStampField() const {
    return genval_type() == FieldVal_TimeStampField ? static_cast<const TimeStampField *>(genval()) : nullptr;
  }
  const IntField *genval_as_IntField() const {
    return genval_type() == FieldVal_IntField ? static_cast<const IntField *>(genval()) : nullptr;
  }
  const VarCharField *genval_as_VarCharField() const {
    return genval_type() == FieldVal_VarCharField ? static_cast<const VarCharField *>(genval()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FIELDNUM) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyFieldVal(verifier, val(), val_type()) &&
           VerifyField<uint8_t>(verifier, VT_GENVAL_TYPE) &&
           VerifyOffset(verifier, VT_GENVAL) &&
           VerifyFieldVal(verifier, genval(), genval_type()) &&
           verifier.EndTable();
  }
};

template<> inline const TimeStampField *Field::val_as<TimeStampField>() const {
  return val_as_TimeStampField();
}

template<> inline const IntField *Field::val_as<IntField>() const {
  return val_as_IntField();
}

template<> inline const VarCharField *Field::val_as<VarCharField>() const {
  return val_as_VarCharField();
}

template<> inline const TimeStampField *Field::genval_as<TimeStampField>() const {
  return genval_as_TimeStampField();
}

template<> inline const IntField *Field::genval_as<IntField>() const {
  return genval_as_IntField();
}

template<> inline const VarCharField *Field::genval_as<VarCharField>() const {
  return genval_as_VarCharField();
}

struct FieldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fieldnum(int32_t fieldnum) {
    fbb_.AddElement<int32_t>(Field::VT_FIELDNUM, fieldnum, -1);
  }
  void add_val_type(FieldVal val_type) {
    fbb_.AddElement<uint8_t>(Field::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(flatbuffers::Offset<void> val) {
    fbb_.AddOffset(Field::VT_VAL, val);
  }
  void add_genval_type(FieldVal genval_type) {
    fbb_.AddElement<uint8_t>(Field::VT_GENVAL_TYPE, static_cast<uint8_t>(genval_type), 0);
  }
  void add_genval(flatbuffers::Offset<void> genval) {
    fbb_.AddOffset(Field::VT_GENVAL, genval);
  }
  explicit FieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldBuilder &operator=(const FieldBuilder &);
  flatbuffers::Offset<Field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Field>(end);
    return o;
  }
};

inline flatbuffers::Offset<Field> CreateField(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t fieldnum = -1,
    FieldVal val_type = FieldVal_NONE,
    flatbuffers::Offset<void> val = 0,
    FieldVal genval_type = FieldVal_NONE,
    flatbuffers::Offset<void> genval = 0) {
  FieldBuilder builder_(_fbb);
  builder_.add_genval(genval);
  builder_.add_val(val);
  builder_.add_fieldnum(fieldnum);
  builder_.add_genval_type(genval_type);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TupleTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Tuple";
  }
  enum {
    VT_SCHEMA = 4,
    VT_FIELDS = 6,
    VT_ISDUMMY = 8
  };
  const Schema *schema() const {
    return GetPointer<const Schema *>(VT_SCHEMA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Field>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Field>> *>(VT_FIELDS);
  }
  bool isdummy() const {
    return GetField<uint8_t>(VT_ISDUMMY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.Verify(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<uint8_t>(verifier, VT_ISDUMMY) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_schema(flatbuffers::Offset<Schema> schema) {
    fbb_.AddOffset(Tuple::VT_SCHEMA, schema);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Field>>> fields) {
    fbb_.AddOffset(Tuple::VT_FIELDS, fields);
  }
  void add_isdummy(bool isdummy) {
    fbb_.AddElement<uint8_t>(Tuple::VT_ISDUMMY, static_cast<uint8_t>(isdummy), 0);
  }
  explicit TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TupleBuilder &operator=(const TupleBuilder &);
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Schema> schema = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Field>>> fields = 0,
    bool isdummy = false) {
  TupleBuilder builder_(_fbb);
  builder_.add_fields(fields);
  builder_.add_schema(schema);
  builder_.add_isdummy(isdummy);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tuple> CreateTupleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Schema> schema = 0,
    const std::vector<flatbuffers::Offset<Field>> *fields = nullptr,
    bool isdummy = false) {
  return CreateTuple(
      _fbb,
      schema,
      fields ? _fbb.CreateVector<flatbuffers::Offset<Field>>(*fields) : 0,
      isdummy);
}

struct Expr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExprTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Expr";
  }
  enum {
    VT_EXPR_TYPE = 4,
    VT_EXPR = 6
  };
  ExprUnion expr_type() const {
    return static_cast<ExprUnion>(GetField<uint8_t>(VT_EXPR_TYPE, 0));
  }
  const void *expr() const {
    return GetPointer<const void *>(VT_EXPR);
  }
  template<typename T> const T *expr_as() const;
  const EqExpr *expr_as_EqExpr() const {
    return expr_type() == ExprUnion_EqExpr ? static_cast<const EqExpr *>(expr()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXPR_TYPE) &&
           VerifyOffset(verifier, VT_EXPR) &&
           VerifyExprUnion(verifier, expr(), expr_type()) &&
           verifier.EndTable();
  }
};

template<> inline const EqExpr *Expr::expr_as<EqExpr>() const {
  return expr_as_EqExpr();
}

struct ExprBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expr_type(ExprUnion expr_type) {
    fbb_.AddElement<uint8_t>(Expr::VT_EXPR_TYPE, static_cast<uint8_t>(expr_type), 0);
  }
  void add_expr(flatbuffers::Offset<void> expr) {
    fbb_.AddOffset(Expr::VT_EXPR, expr);
  }
  explicit ExprBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExprBuilder &operator=(const ExprBuilder &);
  flatbuffers::Offset<Expr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Expr>(end);
    return o;
  }
};

inline flatbuffers::Offset<Expr> CreateExpr(
    flatbuffers::FlatBufferBuilder &_fbb,
    ExprUnion expr_type = ExprUnion_NONE,
    flatbuffers::Offset<void> expr = 0) {
  ExprBuilder builder_(_fbb);
  builder_.add_expr(expr);
  builder_.add_expr_type(expr_type);
  return builder_.Finish();
}

struct Table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Table";
  }
  enum {
    VT_SCHEMA = 4,
    VT_TUPLES = 6
  };
  const Schema *schema() const {
    return GetPointer<const Schema *>(VT_SCHEMA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tuple>> *tuples() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tuple>> *>(VT_TUPLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           VerifyOffset(verifier, VT_TUPLES) &&
           verifier.Verify(tuples()) &&
           verifier.VerifyVectorOfTables(tuples()) &&
           verifier.EndTable();
  }
};

struct TableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_schema(flatbuffers::Offset<Schema> schema) {
    fbb_.AddOffset(Table::VT_SCHEMA, schema);
  }
  void add_tuples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tuple>>> tuples) {
    fbb_.AddOffset(Table::VT_TUPLES, tuples);
  }
  explicit TableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableBuilder &operator=(const TableBuilder &);
  flatbuffers::Offset<Table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Table>(end);
    return o;
  }
};

inline flatbuffers::Offset<Table> CreateTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Schema> schema = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tuple>>> tuples = 0) {
  TableBuilder builder_(_fbb);
  builder_.add_tuples(tuples);
  builder_.add_schema(schema);
  return builder_.Finish();
}

inline flatbuffers::Offset<Table> CreateTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Schema> schema = 0,
    const std::vector<flatbuffers::Offset<Tuple>> *tuples = nullptr) {
  return CreateTable(
      _fbb,
      schema,
      tuples ? _fbb.CreateVector<flatbuffers::Offset<Tuple>>(*tuples) : 0);
}

inline bool VerifyExprUnion(flatbuffers::Verifier &verifier, const void *obj, ExprUnion type) {
  switch (type) {
    case ExprUnion_NONE: {
      return true;
    }
    case ExprUnion_EqExpr: {
      auto ptr = reinterpret_cast<const EqExpr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyExprUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExprUnion(
        verifier,  values->Get(i), types->GetEnum<ExprUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyFieldVal(flatbuffers::Verifier &verifier, const void *obj, FieldVal type) {
  switch (type) {
    case FieldVal_NONE: {
      return true;
    }
    case FieldVal_TimeStampField: {
      auto ptr = reinterpret_cast<const TimeStampField *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FieldVal_IntField: {
      auto ptr = reinterpret_cast<const IntField *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FieldVal_VarCharField: {
      auto ptr = reinterpret_cast<const VarCharField *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyFieldValVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFieldVal(
        verifier,  values->Get(i), types->GetEnum<FieldVal>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *FieldTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FieldTypeTypeTable
  };
  static const char * const names[] = {
    "VARCHAR",
    "INT",
    "TIMESTAMP",
    "UNSUPPORTED"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GroupByTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    GroupByTypeTypeTable
  };
  static const char * const names[] = {
    "MINX",
    "COUNT",
    "UNSUPPPORTED"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExprUnionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    EqExprTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "EqExpr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FieldValTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TimeStampFieldTypeTable,
    IntFieldTypeTable,
    VarCharFieldTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TimeStampField",
    "IntField",
    "VarCharField"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProjectListTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "cols"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GroupByDefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    GroupByTypeTypeTable
  };
  static const char * const names[] = {
    "colno",
    "optype"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EqExprTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FieldValTypeTable
  };
  static const char * const names[] = {
    "colno",
    "val_type",
    "val"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TimeStampFieldTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "val"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VarCharFieldTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "val"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntFieldTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "val"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FieldDescTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FieldTypeTypeTable
  };
  static const char * const names[] = {
    "type",
    "name",
    "col"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SchemaTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FieldDescTypeTable
  };
  static const char * const names[] = {
    "fielddescs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FieldTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FieldValTypeTable
  };
  static const char * const names[] = {
    "fieldnum",
    "val_type",
    "val",
    "genval_type",
    "genval"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TupleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SchemaTypeTable,
    FieldTypeTable
  };
  static const char * const names[] = {
    "schema",
    "fields",
    "isdummy"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExprTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ExprUnionTypeTable
  };
  static const char * const names[] = {
    "expr_type",
    "expr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SchemaTypeTable,
    TupleTypeTable
  };
  static const char * const names[] = {
    "schema",
    "tuples"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_VAULTDB_H_
